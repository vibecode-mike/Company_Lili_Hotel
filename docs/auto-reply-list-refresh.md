# 自動回應列表即時更新

## 背景與問題

在自動回應功能中，使用者建立或編輯完一筆自動回應後，會返回列表頁面。然而，列表並不會自動顯示剛才的變更，必須手動重新整理頁面才能看到最新資料。

這對使用者來說是困惑的：「我明明剛剛存好了，為什麼看不到？」

---

## 現有做法

原本的程式碼在「關閉編輯器、返回列表」時，只做了一件事：**切換頁面路徑**。

```javascript
const closeEditor = () => {
  navigate('auto-reply', {});  // 只有導航，沒有重新取資料
};
```

這導致一個問題：雖然資料已經存到後端，但前端的列表還停留在「進入編輯器之前」的快照，沒有去問後端「現在最新的資料是什麼」。

打個比方：你在倉庫放了一箱新貨，但櫃檯的庫存清單沒更新，所以櫃檯看不到這箱貨。

---

## 新的思路

解法很直接：**返回列表時，順便重新拉一次最新資料**。

我們選擇調用 `fetchAutoReplies()` 這個函數，它會：

1. 向後端發送 `GET /api/v1/auto_responses` 請求
2. 後端回傳合併後的 LINE + Facebook 自動回應資料
3. 更新前端的 React 狀態，列表自動重新渲染

### 為什麼不用頁面重整？

| 比較項目 | fetchAutoReplies() | 頁面重整 |
|---------|-------------------|---------|
| 速度 | 快（只請求一個 API） | 慢（重載所有資源） |
| 體驗 | 平滑，無閃爍 | 頁面會閃白 |
| 狀態保留 | 搜尋條件、滾動位置都保留 | 全部重置 |

簡單說：`fetchAutoReplies()` 是「只更新需要的部分」，頁面重整是「把整個應用砍掉重來」。

---

## 關鍵過程

### 修改前的流程

```
使用者儲存 → 後端更新成功 → 返回列表 → 列表顯示舊資料 ❌
```

### 修改後的流程

```
使用者儲存 → 後端更新成功 → 重新取得列表資料 → 返回列表 → 列表顯示新資料 ✓
```

### 程式碼變更

**檔案**：`frontend/src/components/AutoReply.tsx`

```javascript
// 修改前
const closeEditor = () => {
  navigate('auto-reply', {});
};

// 修改後
const closeEditor = useCallback(() => {
  fetchAutoReplies();           // 新增：重新取得最新資料
  navigate('auto-reply', {});
}, [fetchAutoReplies, navigate]);
```

同時在檔案開頭加入 `useCallback` 的引入：

```javascript
import { useMemo, useState, memo, useCallback } from 'react';
```

---

## 總結與要點

### 核心結論

當使用者完成操作後返回列表，應該主動重新獲取資料，而不是假設本地狀態已經正確。

### 可復用的判斷原則

1. **資料變更後，顯示該資料的頁面應該重新取得最新版本**
   - 不要依賴「儲存時順便更新本地狀態」這種隱性同步
   - 明確調用一次 API 更可靠

2. **優先使用 API 重新取得，而非頁面重整**
   - 更快、體驗更好、保留使用者狀態
   - 這是 SPA（單頁應用）的標準做法

3. **修改範圍越小越好**
   - 這次只改了一個檔案、約 5 行程式碼
   - 沒有動到 Context 或其他共用邏輯，降低影響範圍
