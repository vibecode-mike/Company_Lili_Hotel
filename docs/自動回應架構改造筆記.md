# 自動回應架構改造筆記

## 一、背景與問題

### 問題的起點

這件事源於一個簡單的問題：**「LINE 資料庫的數據 + Facebook 外部 API 的數據，是怎麼顯示在前端的？」**

當我們深入追蹤數據流向時，發現了一個更大的問題。

### 發現的核心困擾

在創建 Facebook 自動回應時，系統做了兩件事：

```
1. 保存到本地資料庫（SQLite/PostgreSQL）
2. 同步到 Facebook 外部 API
```

這看起來很完美——兩邊都有備份。但實際上，**這是一個隱藏的地雷**。

想像一下這個場景：
- 你在超市買東西
- 同時記錄在你的筆記本（本地資料庫）
- 也記錄在超市的系統（外部 API）

如果記錄過程中出了問題會怎樣？

**可能的風險**：

1. **超市記錄成功，但你的筆記本寫壞了**（FB API 成功，本地 commit 失敗）
   - 結果：超市有記錄，你的筆記本沒有
   - 影響：你以為沒買成功，但實際上買了

2. **網絡太慢，你以為沒記錄成功**（網絡超時誤判）
   - 結果：其實超市已經記錄了，但系統誤以為失敗
   - 影響：本地沒記錄，但超市有

3. **兩個人同時記錄**（並發寫入衝突）
   - 結果：後面的人覆蓋了前面的人的記錄
   - 影響：數據丟失

這就是「雙重保存」帶來的核心問題：**兩個數據源可能不一致**。

---

## 二、現有做法及其問題

### 原來的架構

讓我們看看原來是怎麼做的：

#### 後端流程

```python
# 創建 Facebook 自動回應
auto_response = AutoResponse(...)
db.add(auto_response)           # 1. 保存到本地資料庫
await db.commit()               # 2. 提交到本地

# 然後同步到 Facebook API
await _sync_fb_auto_template(...)  # 3. 同步到外部 API
```

#### 前端流程

```typescript
// 獲取自動回應列表（需要兩次調用）
const lineResponse = await apiGet('/api/v1/auto_responses');        // 1. 獲取 LINE 數據
const fbResponse = await apiGet('/api/v1/auto_responses/fb');       // 2. 獲取 FB 數據
const allReplies = [...lineReplies, ...fbReplies];                  // 3. 前端合併
```

### 為什麼這樣做有問題

#### 問題 1：數據不一致的風險

```
時間線：
10:00:00  → 保存到本地資料庫 ✅
10:00:01  → 同步到 FB API ✅
10:00:02  → 本地 commit... ❌ 失敗！

結果：
- FB API 有這筆記錄
- 本地資料庫沒有
- 前端顯示 FB 的自動回應，但無法編輯（因為本地沒記錄）
```

#### 問題 2：前端需要兩次調用

前端要獲取完整的列表，必須：
1. 調用一次獲取 LINE 數據
2. 調用一次獲取 FB 數據
3. 自己合併兩個數據源
4. 自己處理排序

這增加了：
- **網絡開銷**（兩次請求）
- **前端複雜度**（需要理解兩種數據格式並合併）
- **維護成本**（如果增加新平台，前端也要改）

#### 問題 3：多個真實來源

當你有兩個數據源時，總會面臨一個哲學問題：

> **「哪個才是真的？」**

如果 Facebook 官方後台顯示有這個自動回應，但我們本地資料庫沒有，該相信誰？

答案應該很明確：**相信 Facebook API**，因為那才是實際生效的地方。

但原來的架構沒有明確這一點，導致數據不一致時無法判斷。

---

## 三、新的思路

### 靈感來源

我們注意到系統中有一個類似的功能——**活動推播的「已發送」列表**——已經成功解決了這個問題。

它的做法是：

```
1. Facebook 已發送的訊息，不保存到本地資料庫
2. 後端在需要時，從 Facebook API 獲取數據
3. 後端合併「本地 LINE 數據」+「外部 FB 數據」
4. 前端只調用一次 API，獲得完整列表
```

這個模式已經穩定運行，證明是可行的。

### 新方案的核心理念

#### 理念 1：單一真實來源（Single Source of Truth）

對於每一筆數據，應該有且只有一個「真實來源」：

- **LINE 自動回應** → 本地資料庫是真實來源
- **Facebook 自動回應** → Facebook API 是真實來源

這樣就不會有「兩邊不一致該信誰」的問題。

#### 理念 2：後端負責複雜性，前端保持簡單

前端不需要知道：
- 數據來自哪裡（本地 DB 還是外部 API）
- 有幾個數據源
- 怎麼合併

前端只需要：
- 調用一個端點
- 獲得完整的列表
- 顯示給用戶

這是「關注點分離」的體現。

#### 理念 3：參考已有的成功經驗

不要重新發明輪子。活動推播已經證明這個架構可行，我們只需要套用同樣的模式。

---

## 四、關鍵過程

### 改造步驟概覽

整個改造分為四個步驟，每一步都有明確的目的：

```
步驟 1: 添加後端合併函數    → 學習活動推播的合併邏輯
步驟 2: 修改 GET 端點       → 後端合併數據返回
步驟 3: 修改 POST 端點      → FB 不再保存本地
步驟 4: 簡化前端調用        → 從兩次調用改為一次
```

### 步驟 1：添加後端合併函數

#### 為什麼需要這個函數？

要合併數據，首先要有一個地方把 Facebook 的數據「翻譯」成我們內部的格式。

#### 它做了什麼？

```python
async def _get_fb_auto_responses_from_api(jwt_token: str, db: AsyncSession):
    """
    從 Facebook API 獲取自動回應，轉換為內部格式
    """
    # 1. 調用 Facebook API
    fb_client = FbMessageClient()
    result = await fb_client.get_auto_templates(jwt_token)

    # 2. 轉換格式
    for item in fb_data:
        fb_auto_response = {
            "id": f"fb-{item['id']}",     # ← 加上前綴，避免和 LINE 的 ID 衝突
            "name": item['channel_name'],
            "keywords": [...],
            "messages": [...],
            "channels": ["Facebook"],      # ← 標記這是 Facebook 的
            # ... 其他字段
        }

    # 3. 如果失敗，返回空列表（不阻塞 LINE 數據顯示）
    return fb_auto_responses
```

#### 關鍵設計：ID 前綴

為什麼要在 Facebook 的 ID 前面加 `fb-`？

```
LINE 自動回應的 ID：1, 2, 3, 4, 5
Facebook 自動回應的 ID：1, 2, 3

如果不加前綴，會衝突！

加上前綴後：
LINE: 1, 2, 3, 4, 5
Facebook: fb-1, fb-2, fb-3

這樣就不會衝突了
```

### 步驟 2：修改 GET 端點合併數據

#### 之前：只返回本地數據

```python
@router.get("", response_model=SuccessResponse)
async def get_auto_responses(db: AsyncSession):
    # 只查詢本地資料庫
    result = await db.execute(select(AutoResponse))
    return SuccessResponse(data=items)
```

#### 現在：合併 LINE + Facebook 數據

```python
@router.get("", response_model=SuccessResponse)
async def get_auto_responses(
    jwt_token: Optional[str] = Query(None),  # ← 新增：接收 FB token
    db: AsyncSession = Depends(get_db),
):
    # Step 1: 獲取 LINE 自動回應（本地資料庫）
    line_items = [...]

    # Step 2: 獲取 Facebook 自動回應（外部 API）
    fb_items = []
    if jwt_token:
        fb_items = await _get_fb_auto_responses_from_api(jwt_token, db)

    # Step 3: 合併兩個數據源
    all_items = line_items + fb_items

    # Step 4: 按創建時間排序
    all_items.sort(key=lambda x: x['created_at'], reverse=True)

    return SuccessResponse(data=all_items)
```

#### 流程圖

```
前端請求
   ↓
GET /api/v1/auto_responses?jwt_token=xxx
   ↓
   ├─→ 查詢本地資料庫 → LINE 自動回應 [1, 2, 3]
   │
   └─→ 調用 Facebook API → FB 自動回應 [fb-1, fb-2]

合併 → [1, 2, 3, fb-1, fb-2]
   ↓
排序 → [fb-2, 3, fb-1, 2, 1]  （按時間降序）
   ↓
返回給前端
```

### 步驟 3：修改 POST 端點（核心改動）

#### 為什麼這是核心改動？

這一步決定了 Facebook 自動回應不再保存到本地資料庫。

#### 新增的判斷邏輯

```python
@router.post("", response_model=SuccessResponse)
async def create_auto_response(data: AutoResponseCreate, jwt_token: Optional[str]):

    # ✅ 判斷：如果是純 Facebook 渠道
    if channels == ['Facebook']:
        logger.info("⚡ 純 FB 自動回應，只保存到外部 API")

        # 直接調用 Facebook API（不保存本地）
        fb_client = FbMessageClient()
        result = await fb_client.set_auto_template(payload, jwt_token)

        # 返回 Facebook ID（加上 fb- 前綴）
        return SuccessResponse(
            data={"id": f"fb-{fb_id}", "external_only": True},
            message="創建成功（已保存到 Facebook API）"
        )

    # ✅ LINE 或混合渠道：繼續保存到本地資料庫
    auto_response = AutoResponse(...)
    db.add(auto_response)
    await db.commit()
```

#### 決策樹

```
創建自動回應
   ↓
判斷渠道
   ↓
   ├─ channels = ['Facebook']         → 只調用 FB API，不保存本地
   │                                    返回 {"id": "fb-123"}
   │
   ├─ channels = ['LINE']              → 只保存本地資料庫
   │                                    返回 {"id": 5}
   │
   └─ channels = ['LINE', 'Facebook']  → 保存本地 + 同步 FB API
                                        返回 {"id": 6}
```

### 步驟 4：簡化前端調用

#### 之前：兩次調用 + 手動合併

```typescript
const fetchAutoReplies = async () => {
    // 1. 獲取 LINE 數據
    const lineResponse = await apiGet('/api/v1/auto_responses');
    const lineReplies = lineResult.data.map(mapAutoResponse);

    // 2. 獲取 Facebook 數據
    const fbResponse = await apiGet('/api/v1/auto_responses/fb?jwt_token=...');
    const fbReplies = fbResult.data.map(mapFbAutoResponse);

    // 3. 手動合併
    const allReplies = [...lineReplies, ...fbReplies];

    // 4. 排序
    setAutoReplies(sortByCreatedAt(allReplies));
}
```

#### 現在：一次調用，後端已處理

```typescript
const fetchAutoReplies = async () => {
    // ✅ 一次調用，後端已經合併好了
    const jwtToken = getJwtToken();
    const url = jwtToken
        ? `/api/v1/auto_responses?jwt_token=${jwtToken}`
        : '/api/v1/auto_responses';

    const response = await apiGet(url);
    const allReplies = result.data.map(mapAutoResponse);

    setAutoReplies(sortByCreatedAt(allReplies));
}
```

#### 對比

| 項目 | 之前 | 現在 |
|------|------|------|
| API 調用次數 | 2 次 | 1 次 |
| 數據合併邏輯 | 在前端 | 在後端 |
| 需要理解的數據格式 | 2 種 | 1 種（統一格式） |
| 代碼行數 | ~40 行 | ~15 行 |

---

## 五、架構對比

### 視覺化對比

#### 舊架構：雙重保存 + 前端合併

```
前端
  │
  ├─ GET /api/v1/auto_responses ──────→ 本地 DB ──→ LINE 數據
  │                                                    ↓
  │                                                  前端
  │                                                  合併
  │                                                    ↓
  └─ GET /api/v1/auto_responses/fb ───→ FB API ───→ FB 數據

創建 FB 自動回應
  │
  POST /api/v1/auto_responses
  ├─→ 保存到本地 DB      ✅
  └─→ 同步到 FB API      ✅ (可能失敗導致不一致 ❌)
```

**問題**：
- ❌ 兩個數據源（本地 DB + FB API）
- ❌ 可能不一致
- ❌ 前端需要合併邏輯

#### 新架構：單一來源 + 後端合併

```
前端
  │
  GET /api/v1/auto_responses?jwt_token=xxx
  │
  └─→ 後端
        ├─→ 本地 DB ──→ LINE 數據
        │                  ↓
        └─→ FB API ────→ FB 數據
                           ↓
                        後端合併
                           ↓
                        統一返回

創建 FB 自動回應
  │
  POST /api/v1/auto_responses
  │
  判斷渠道
  ├─ 純 FB ────→ 只調用 FB API ✅ (單一來源)
  └─ LINE/混合 → 本地 DB + FB API
```

**優勢**：
- ✅ 單一真實來源（FB API）
- ✅ 無數據不一致風險
- ✅ 前端簡化（一次調用）

---

## 六、實際運作流程

### 場景 1：用戶查看自動回應列表

```
用戶點擊「自動回應」頁面
   ↓
前端調用: GET /api/v1/auto_responses?jwt_token=xxx
   ↓
後端處理:
   ├─ 查詢本地資料庫 → 找到 3 筆 LINE 自動回應
   └─ 調用 FB API → 找到 2 筆 FB 自動回應
   ↓
後端合併: [LINE-1, LINE-2, LINE-3, fb-1, fb-2]
   ↓
後端排序: 按創建時間降序
   ↓
返回給前端: [fb-2, LINE-3, fb-1, LINE-2, LINE-1]
   ↓
前端顯示表格（用戶看到 5 筆自動回應）
```

### 場景 2：用戶創建 Facebook 自動回應

```
用戶填寫表單:
  - 名稱: "週末促銷"
  - 渠道: Facebook
  - 關鍵字: ["促銷", "優惠"]
  - 訊息: "週末全場 8 折！"
   ↓
前端調用: POST /api/v1/auto_responses?jwt_token=xxx
   ↓
後端判斷: channels = ['Facebook'] → 純 FB 渠道
   ↓
後端邏輯:
   ├─ 不保存到本地資料庫 ❌
   └─ 調用 FB API 創建 ✅
   ↓
FB API 返回: {"id": 123}
   ↓
後端返回: {"id": "fb-123", "external_only": true}
   ↓
前端重新獲取列表 → 能看到新創建的自動回應
```

### 場景 3：用戶創建 LINE 自動回應

```
用戶填寫表單:
  - 名稱: "歡迎訊息"
  - 渠道: LINE
  - 訊息: "歡迎加入！"
   ↓
前端調用: POST /api/v1/auto_responses
   ↓
後端判斷: channels = ['LINE'] → 純 LINE 渠道
   ↓
後端邏輯:
   ├─ 保存到本地資料庫 ✅
   └─ 不調用 FB API ❌
   ↓
資料庫返回: id = 10
   ↓
後端返回: {"id": 10}
   ↓
前端重新獲取列表 → 能看到新創建的自動回應
```

---

## 七、總結與要點

### 核心經驗

#### 1. 單一真實來源原則

> **每一筆數據應該有且只有一個「真實來源」**

這個原則適用於所有涉及外部服務的場景：

- Facebook 數據 → Facebook API 是真實來源
- Google 數據 → Google API 是真實來源
- 本地業務數據 → 本地資料庫是真實來源

**違反這個原則的後果**：數據不一致、難以判斷哪個是正確的。

#### 2. 後端負責複雜性

> **把複雜的邏輯放在後端，讓前端保持簡單**

前端應該：
- 調用簡單的 API
- 顯示數據
- 處理用戶交互

前端不應該：
- 理解多個數據源
- 手動合併數據
- 處理數據格式轉換

**好處**：
- 前端代碼更易維護
- 邏輯集中在後端，修改時只改一個地方
- 新增平台時，前端不需要改動

#### 3. 參考已有的成功經驗

> **不要重新發明輪子，借鑒已有的成功模式**

活動推播的「已發送」列表已經證明：
- 外部數據不保存本地是可行的
- 後端合併數據是穩定的
- 這個架構能滿足需求

所以我們直接套用這個模式，而不是嘗試新的、未經驗證的方案。

### 可復用的判斷原則

#### 何時不保存到本地資料庫？

當滿足以下**所有條件**時，可以不保存到本地：

1. ✅ 外部 API 是權威的真實來源（如 Facebook API）
2. ✅ 數據的生命週期由外部系統管理（如訊息發送狀態）
3. ✅ 本地保存只是為了「方便」，不是業務必需
4. ✅ 外部 API 可靠且訪問速度可接受

**反例**（應該保存本地）：
- 訂單數據（本地是真實來源）
- 用戶資料（需要快速訪問）
- 關鍵業務數據（不能依賴外部服務）

#### 何時讓後端合併數據？

當滿足以下**任一條件**時，應該後端合併：

1. ✅ 數據來自多個來源（本地 DB + 外部 API）
2. ✅ 合併邏輯可能變化（增加新平台）
3. ✅ 前端有多個（Web、App、小程序）
4. ✅ 需要統一的排序或過濾邏輯

**好處**：
- 邏輯集中管理
- 前端保持簡單
- 容易擴展

### 值得記住的反模式

#### 反模式 1：雙重保存外部數據

```python
# ❌ 不好：外部數據也保存本地
external_data = await external_api.create(...)
local_db.save(external_data)  # 可能不一致

# ✅ 好：外部數據只存外部
external_data = await external_api.create(...)
return external_data.id  # 不保存本地
```

#### 反模式 2：前端合併多個數據源

```typescript
// ❌ 不好：前端合併
const data1 = await api1.fetch();
const data2 = await api2.fetch();
const merged = [...data1, ...data2];

// ✅ 好：後端合併
const merged = await api.fetchMerged();
```

#### 反模式 3：盲目追求完整性

```python
# ❌ 不好：為了「完整」而保存所有東西
fb_message = await fb_api.send(...)
db.save(fb_message)  # 「以防萬一」

# ✅ 好：明確數據的真實來源
fb_message = await fb_api.send(...)
# 不保存，需要時從 FB API 獲取
```

### 最後的建議

當你面對類似的問題時，問自己三個問題：

1. **誰是這筆數據的主人？**
   - 如果是外部服務（如 Facebook），讓它當主人

2. **保存到本地是為了什麼？**
   - 如果只是「方便」或「備份」，可能不需要

3. **有沒有已經成功的案例可以參考？**
   - 如果有，優先套用已驗證的模式

記住：**簡單比複雜好，明確比模糊好，一個真實來源比多個來源好。**

---

**改造完成日期**: 2026-01-24
**參考架構**: 活動推播 `message_service.py` 的合併模式
**核心原則**: 單一真實來源、後端負責複雜性、參考成功經驗
