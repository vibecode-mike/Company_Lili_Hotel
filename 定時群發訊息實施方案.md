# 定時自動發布群發訊息 - 解決方案分析

## 當前系統狀況

- ✅ 已有 APScheduler（apscheduler==3.10.4）
- ✅ 已有 LINE API 整合（multicast_message 群發功能）
- ✅ 資料庫已有 scheduled_at 和 status 欄位

---

## 解決方案對比

### 🏆 方案一：APScheduler（推薦 - 已安裝）

**優點：**
- ✅ 已安裝，無需額外依賴
- ✅ 輕量級，適合中小型應用
- ✅ 支援多種觸發器（interval, cron, date）
- ✅ 可持久化到資料庫（防止重啟丟失）
- ✅ 與 FastAPI 整合簡單

**缺點：**
- ⚠️ 單機運行，不支援分散式
- ⚠️ 高併發場景性能有限

**實現步驟：**
1. 創建 `app/scheduler.py` 設定 APScheduler
2. 創建定時任務函數 `check_and_send_campaigns()`
3. 在 `main.py` 啟動時初始化 scheduler
4. 每分鐘檢查 `scheduled_at <= now AND status = 'scheduled'`
5. 發送訊息並更新狀態為 SENT

---

## 🎯 推薦實現方案：APScheduler

### 核心設計

#### 1. Scheduler 初始化

```python
# app/scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore

scheduler = AsyncIOScheduler()
scheduler.add_jobstore(SQLAlchemyJobStore(url=DATABASE_URL))
```

#### 2. 定時任務邏輯

```python
async def check_and_send_campaigns():
    # 查詢：scheduled_at <= now AND status = 'scheduled'
    # 遍歷活動：
    #   1. 獲取目標會員 LINE UID
    #   2. 構建訊息內容
    #   3. 調用 line_service.multicast_message()
    #   4. 更新狀態為 SENT，記錄 sent_at
    #   5. 更新 sent_count
```

#### 3. 任務觸發器

- **IntervalTrigger**: 每 1 分鐘檢查一次
- 或 **DateTrigger**: 為每個活動創建獨立定時任務（更精確）

---

## 架構流程

```
用戶操作 → 選擇「定時發送」→ 設定 scheduled_at
                    ↓
            狀態設為 SCHEDULED
                    ↓
    APScheduler 每分鐘檢查 ← scheduled_at <= now?
                    ↓ YES
    調用 LINE API 群發 → 更新狀態為 SENT
                    ↓
            記錄發送結果
```

---

## 實現細節

### 檔案結構

```
backend/
├── app/
│   ├── scheduler.py          # APScheduler 配置
│   ├── tasks/
│   │   ├── __init__.py
│   │   └── campaign.py       # 群發任務邏輯
│   ├── services/
│   │   └── line_service.py   # LINE API 封裝
│   └── main.py               # 啟動 scheduler
```

### 關鍵代碼點

1. **app/scheduler.py** - 配置 scheduler
2. **app/tasks/campaign.py** - 實現 `send_scheduled_campaigns()`
3. **app/services/line_service.py** - LINE API 封裝
4. **app/main.py** - 應用啟動時啟動 scheduler
5. 發送邏輯整合 `line_service.multicast_message()`

---

## 容錯處理

1. **失敗重試**：記錄失敗原因到 `campaign.error_message`
2. **狀態更新**：失敗設為 FAILED，成功設為 SENT
3. **配額檢查**：發送前檢查 LINE API 配額
4. **批次處理**：500 人/批次（LINE API 限制）

---

## 時間精確度

- **方案 A**：每分鐘輪詢（簡單，誤差 <60 秒）✅ 推薦
- **方案 B**：為每個活動創建 DateTrigger（精確到秒，但任務數多）

**推薦方案 A**，誤差可接受，系統負載低。

---

## 實現清單

### Phase 1: 核心功能

- [ ] 創建 `app/scheduler.py` 配置
- [ ] 創建 `app/tasks/__init__.py`
- [ ] 創建 `app/tasks/campaign.py` 任務邏輯
- [ ] 創建 `app/services/line_service.py` LINE API 封裝
- [ ] 整合 LINE API 發送功能
- [ ] 在 `main.py` 啟動 scheduler
- [ ] 測試定時發送功能

### Phase 2: 增強功能（可選）

- [ ] 添加任務執行歷史記錄
- [ ] 實現發送速率限制
- [ ] 添加失敗重試機制
- [ ] 實現任務暫停/恢復功能
- [ ] 添加任務執行監控和告警

---

## 核心實施架構

### 系統流程圖

```
┌─────────────────┐
│  用戶建立活動    │ → scheduled_at + status=SCHEDULED
└────────┬────────┘
         ↓
┌─────────────────┐
│ APScheduler     │ → 每分鐘執行 check_and_send_campaigns()
│ (每分鐘輪詢)    │
└────────┬────────┘
         ↓
┌─────────────────┐
│ 查詢到期活動    │ → WHERE scheduled_at <= NOW() AND status='scheduled'
└────────┬────────┘
         ↓
┌─────────────────┐
│ 獲取目標會員    │ → 根據 target_audience 查詢會員 LINE UID
└────────┬────────┘
         ↓
┌─────────────────┐
│ LINE API 群發   │ → multicast_message(uids, message)
└────────┬────────┘
         ↓
┌─────────────────┐
│ 更新狀態        │ → status=SENT, sent_at=NOW()
└─────────────────┘
```

---

## 技術實施細節

### 1. 輪詢策略（方案 A - 推薦）

- **輪詢頻率**: 每 1 分鐘
- **查詢條件**: `scheduled_at <= NOW() AND status = 'scheduled'`
- **批次處理**: 每批次最多 500 人（LINE API 限制）
- **時間誤差**: <60 秒（業務可接受）

### 2. 錯誤處理機制

```python
try:
    # 發送訊息
    await line_service.multicast_message(uids, message)
    campaign.status = CampaignStatus.SENT
    campaign.sent_at = datetime.now()
except Exception as e:
    campaign.status = CampaignStatus.FAILED
    campaign.error_message = str(e)
    logger.error(f"Campaign {campaign.id} failed: {e}")
```

### 3. LINE API 整合

- **SDK**: `line-bot-sdk==3.6.0`
- **API**: `multicast_message(to: List[str], messages: List[Message])`
- **限制**: 500 recipients/request
- **處理策略**: 自動分批發送

### 4. 狀態管理

| 狀態 | 說明 | 觸發時機 |
|------|------|----------|
| DRAFT | 草稿 | 初始創建 |
| SCHEDULED | 已排程 | 設定 scheduled_at |
| SENT | 已發送 | 發送成功 |
| FAILED | 發送失敗 | 發送異常 |

---

## 資料庫設計

### Campaign 表（已存在）

```python
class Campaign(Base):
    id = Column(BigInteger, primary_key=True)
    title = Column(String(100))
    scheduled_at = Column(DateTime)  # 排程時間
    sent_at = Column(DateTime)       # 實際發送時間
    status = Column(Enum(CampaignStatus))  # DRAFT/SCHEDULED/SENT/FAILED
    sent_count = Column(Integer)     # 發送人數
    error_message = Column(String(500))  # 錯誤訊息（新增建議）
```

### 建議新增欄位

```sql
ALTER TABLE campaigns ADD COLUMN error_message VARCHAR(500) COMMENT '錯誤訊息';
```

---

## 部署考量

### 1. 生產環境配置

```python
# config.py
SCHEDULER_ENABLED = True  # 可透過環境變數控制
SCHEDULER_CHECK_INTERVAL = 60  # 檢查間隔（秒）
SCHEDULER_TIMEZONE = "Asia/Taipei"  # 時區設定
```

### 2. 監控指標

- 任務執行次數
- 發送成功率
- 平均執行時間
- 失敗任務數量

### 3. 日誌記錄

```python
logger.info(f"Scheduled task started at {datetime.now()}")
logger.info(f"Found {len(campaigns)} campaigns to send")
logger.info(f"Campaign {campaign.id} sent to {sent_count} recipients")
```

---

## 測試計劃

### 1. 單元測試

- 測試輪詢邏輯
- 測試狀態更新
- 測試錯誤處理

### 2. 整合測試

- 測試立即發送
- 測試定時發送（1分鐘後）
- 測試批次發送（>500人）

### 3. 壓力測試

- 同時 10 個排程任務
- 單次發送 1000+ 人

---

## 風險評估

| 風險 | 影響 | 緩解措施 |
|------|------|----------|
| LINE API 配額耗盡 | 高 | 發送前檢查配額 |
| 任務執行失敗 | 中 | 完善錯誤處理和日誌 |
| 時間漂移 | 低 | 每分鐘檢查可接受 |
| 重複發送 | 高 | 狀態檢查防重複 |

---

## 實施時間表

| 階段 | 任務 | 預計時間 |
|------|------|----------|
| Phase 1 | 基礎功能實現 | 2-3 小時 |
| Phase 2 | 測試和除錯 | 1 小時 |
| Phase 3 | 文檔和部署 | 0.5 小時 |

**總計**: 約 3.5-4.5 小時

---

## 後續優化方向

### 短期（1-2週）

- 添加任務執行歷史
- 實現重試機制
- 添加監控告警

### 中期（1-2月）

- 支援重複性任務（每日/每週）
- 智能發送時間優化
- AB 測試支持

### 長期（3-6月）

- 遷移到 Celery（如需分散式）
- 實現優先級隊列
- 機器學習最佳發送時間

---

## 參考資源

- [APScheduler 官方文檔](https://apscheduler.readthedocs.io/)
- [LINE Messaging API](https://developers.line.biz/en/docs/messaging-api/)
- [FastAPI Background Tasks](https://fastapi.tiangolo.com/tutorial/background-tasks/)

---

**最後更新**: 2025-01-09
**版本**: v1.0
**狀態**: 待實施
