# TDD 重構階段：改善程式碼品質

## 目標

在 TDD 的綠燈階段，我們已經讓所有測試通過（綠燈 🟢）。現在進入重構階段：

**在保持測試通過的前提下，改善程式碼品質。**

重構不是重寫，而是透過一系列小步驟逐步改善程式碼的內部結構，同時保持外部行為不變。

---

## 核心原則

### 1. 測試保護原則

**每次重構後都要確保所有測試仍然通過。**

```
重構前 → 跑測試 ✅ 全部通過
↓
進行重構
↓
重構後 → 立即跑測試 ✅ 必須全部通過
```

如果測試失敗，立即回滾，找出問題。

### 2. 小步前進原則

**一次只做一個小重構，不要一次改太多。**

```
Step 1: 小重構 → 跑測試 ✅
Step 2: 小重構 → 跑測試 ✅
Step 3: 小重構 → 跑測試 ✅
```

### 3. 保持行為不變原則

**重構只改內部結構，不改外部行為。**

不要在重構時加入新功能或改變邏輯。

---

## 常見改善方向

重構的目的是改善程式碼品質，常見的改善包括：

- **提升可讀性**：更清晰的命名、更短的方法
- **消除重複**：將重複的程式碼提取出來
- **簡化邏輯**：將複雜的條件判斷簡化
- **改善結構**：將相關的程式碼組織在一起

具體如何重構，依賴你對程式碼品質的判斷和經驗。

### ⚠️ 關鍵提醒：不要強行重構

**如果沒有找到明確需要改善的地方，就不要強行重構。**

重構的原則是「改善程式碼品質」，而不是「為了重構而重構」。

```
❌ 不要這樣做：
- 程式碼已經簡潔清晰了，還要硬生生地提取方法
- 沒有重複的地方，還要人為制造通用邏輯
- 強行使用設計模式，導致程式碼變複雜

✅ 正確的做法：
- 只在真正有改善空間時才進行重構
- 如果程式碼已經可讀且沒有重複，就保持原樣
- 遵循 YAGNI 原則（You Aren't Gonna Need It）
```

**重構的黃金法則**：在測試保護下，有價值的改善就做，沒有就跳過。

---

## 重構流程

```
1. 確認測試通過（綠燈 🟢）
2. 進行重構
3. 執行測試 → 確認仍然通過 ✅
4. 若測試失敗 → 回滾，找出問題
5. 完成重構 → 進入下一個 TDD 循環
```

---

## 測試程式碼中的 Meta 註記清理

### 目的
在重構階段，清理測試程式碼中的 **meta 註記**（事件風暴部位、Handler 參考等），保留必要的業務邏輯註解。

### 背景
在紅燈階段（02-紅燈.md），測試程式碼中包含大量 meta 註記，用於識別事件風暴部位和 Handler 參考：

```python
# Given 用戶 "Alice" 在課程 1 的狀態為 "進行中"
# [事件風暴部位: Aggregate - LessonProgress]
# [生成參考 Prompt: Aggregate-Given-Handler.md]
```

這些 meta 註記在開發過程中很有用，但在重構階段應該被移除。

### 清理規則

#### ✅ 保留的註解
- **Given/When/Then/And** 的業務邏輯描述
- 說明測試目的的註解
- 解釋複雜邏輯的註解
- 提取變數的用途說明

#### ❌ 刪除的 Meta 註記
- `# [事件風暴部位: ...]`
- `# [生成參考 Prompt: ...]`
- 所有涉及開發流程跟蹤的元資料註記

### 範例

#### 重構前（紅燈階段）
```python
def test_無法提交非挑戰題課程的作業(self, setup_background):
    """Example: 無法提交非挑戰題課程的作業"""
    
    # Extract repositories and services from fixture
    lesson_progress_repository = setup_background["lesson_progress_repository"]
    lesson_service = setup_background["lesson_service"]
    
    # Given 用戶 "Alice" 在課程 1 的狀態為 "進行中"
    # [事件風暴部位: Aggregate - LessonProgress]
    # [生成參考 Prompt: Aggregate-Given-Handler.md]
    progress = LessonProgress(
        user_id="Alice",
        lesson_id=1,
        progress=0,
        status="IN_PROGRESS"
    )
    lesson_progress_repository.save(progress)
    
    # When 用戶 "Alice" 提交課程 1 的挑戰題作業
    # [事件風暴部位: Command - submit_challenge]
    # [生成參考 Prompt: Command-Handler.md]
    # Then 操作失敗
    # [生成參考 Prompt: Success-Failure-Handler.md]
    with pytest.raises(InvalidStateError):
        lesson_service.submit_challenge(user_id="Alice", lesson_id=1)
    
    # And 用戶 "Alice" 在課程 1 的狀態應為 "進行中"
    # [事件風暴部位: Aggregate - LessonProgress]
    # [生成參考 Prompt: Aggregate-Then-Handler.md]
    unchanged_progress = lesson_progress_repository.find(user_id="Alice", lesson_id=1)
    assert unchanged_progress.status == "IN_PROGRESS"
```

#### 重構後（清理 Meta 註記）
```python
def test_無法提交非挑戰題課程的作業(self, setup_background):
    """Example: 無法提交非挑戰題課程的作業"""
    
    # Extract repositories and services from fixture
    lesson_progress_repository = setup_background["lesson_progress_repository"]
    lesson_service = setup_background["lesson_service"]
    
    # Given 用戶 "Alice" 在課程 1 的狀態為 "進行中"
    progress = LessonProgress(
        user_id="Alice",
        lesson_id=1,
        progress=0,
        status="IN_PROGRESS"
    )
    lesson_progress_repository.save(progress)
    
    # When 用戶 "Alice" 提交課程 1 的挑戰題作業
    # Then 操作失敗
    with pytest.raises(InvalidStateError):
        lesson_service.submit_challenge(user_id="Alice", lesson_id=1)
    
    # And 用戶 "Alice" 在課程 1 的狀態應為 "進行中"
    unchanged_progress = lesson_progress_repository.find(user_id="Alice", lesson_id=1)
    assert unchanged_progress.status == "IN_PROGRESS"
```

### 清理步驟

1. **保留** Given/When/Then/And 的業務邏輯描述
2. **保留** 必要的技術實現註解（如 "Extract repositories and services"）
3. **刪除** 所有 `[事件風暴部位: ...]` 的行
4. **刪除** 所有 `[生成參考 Prompt: ...]` 的行
5. **確認測試仍然通過** ✅

### ⚠️ 重要提醒

- **千萬不要刪除 Given/When/Then 的業務邏輯描述**，這些對理解測試很重要
- **只刪除 meta 註記**，這些是開發流程的輔助資訊，不是測試邏輯的一部分
- **每次刪除後都要跑測試**，確保沒有意外破壞任何邏輯

---

## 記住

重構的核心精神：
1. **在測試保護下改善程式碼品質**
2. **小步前進，頻繁測試**
3. **只改結構，不改行為**

---

## 測試程式碼的依賴管理重構

### 目的
將測試中重複的依賴初始化代碼提取到 pytest fixture 中，減少重複、提升可維護性。

### 問題：重複的依賴初始化

在未重構前，每個測試方法都需要重複建立相同的依賴：

```python
def test_查詢進行中的影片課程進度(self):
    # ❌ 每個測試都要重複這些代碼
    lesson_progress_repository = LessonProgressRepository()
    lesson_repository = LessonRepository()
    user_repository = UserRepository()
    subscription_repository = JourneySubscriptionRepository()
    
    lesson_service = LessonService(
        lesson_progress_repository=lesson_progress_repository,
        lesson_repository=lesson_repository,
        user_repository=user_repository,
        subscription_repository=subscription_repository,
    )
    
    # 還要建立測試數據
    user_alice = User(name="Alice", level=1, exp=0)
    user_repository.save(user_alice)
    
    lesson1 = Lesson(name="物件導向基礎", ...)
    lesson_repository.save(lesson1)
    
    subscription_repository.subscribe("Alice", 1)
    
    # 真正的測試邏輯才開始...
```

**缺點**：
- 大量重複代碼
- 修改依賴時需要改動多處
- 測試邏輯被淹沒在初始化代碼中
- 違反 DRY (Don't Repeat Yourself) 原則

### 解決方案：使用 pytest fixture 統一管理

#### 步驟 1：建立 setup_background fixture

將所有測試的共用前置條件提取到一個 fixture 中：

```python
@pytest.fixture
def setup_background():
    """
    Background: 測試的共用前置條件
    """
    # Arrange: 初始化 repositories 和 services
    lesson_progress_repository = LessonProgressRepository()
    lesson_repository = LessonRepository()
    user_repository = UserRepository()
    subscription_repository = JourneySubscriptionRepository()
    
    journey_service = JourneyService(
        user_repository=user_repository,
        subscription_repository=subscription_repository,
    )
    
    lesson_service = LessonService(
        lesson_progress_repository=lesson_progress_repository,
        lesson_repository=lesson_repository,
        user_repository=user_repository,
        subscription_repository=subscription_repository,
    )
    
    # Given 系統中有以下課程：
    lesson1 = Lesson(name="物件導向基礎", ...)
    lesson_repository.save(lesson1)
    
    # And 系統中有以下用戶：
    user_alice = User(name="Alice", level=1, exp=0)
    user_repository.save(user_alice)
    
    user_bob = User(name="Bob", level=1, exp=0)
    user_repository.save(user_bob)
    
    # And 用戶 "Alice" 已訂閱旅程 1
    journey_service.subscribe_journey(user_id="Alice", journey_id=1)
    
    # Return 所有需要的 repositories 和 services
    return {
        "lesson_repository": lesson_repository,
        "user_repository": user_repository,
        "lesson_progress_repository": lesson_progress_repository,
        "subscription_repository": subscription_repository,
        "journey_service": journey_service,
        "lesson_service": lesson_service,
    }
```

#### 步驟 2：簡化測試方法

測試方法只需從 fixture 中提取需要的依賴：

```python
def test_查詢進行中的影片課程進度(self, setup_background):
    """Example: 查詢進行中的影片課程進度"""
    
    # ✅ Extract repositories and services from fixture
    lesson_progress_repository = setup_background["lesson_progress_repository"]
    lesson_service = setup_background["lesson_service"]
    
    # Given 用戶 "Alice" 在課程 1 的進度為 70%，狀態為 "進行中"
    progress = LessonProgress(
        user_id="Alice",
        lesson_id=1,
        progress=70,
        status=PROGRESS_STATUS_IN_PROGRESS,
    )
    lesson_progress_repository.save(progress)
    
    # When 用戶 "Alice" 查詢課程 1 的進度
    result = lesson_service.get_lesson_progress(user_id="Alice", lesson_id=1)
    
    # Then 操作成功
    assert result.user_name == "Alice"
    assert result.lesson_id == 1
    assert result.progress == 70
```

### 重構效果對比

#### 重構前
```python
def test_example(self):
    # 30+ 行的依賴初始化代碼
    lesson_progress_repository = LessonProgressRepository()
    lesson_repository = LessonRepository()
    user_repository = UserRepository()
    subscription_repository = JourneySubscriptionRepository()
    lesson_service = LessonService(...)
    user_alice = User(...)
    user_repository.save(user_alice)
    lesson1 = Lesson(...)
    lesson_repository.save(lesson1)
    subscription_repository.subscribe(...)
    
    # 真正的測試邏輯（5 行）
    progress = LessonProgress(...)
    result = lesson_service.query(...)
    assert result.status == "completed"
```

**行數**: ~35 行  
**可讀性**: 差（測試邏輯被淹沒）  
**維護性**: 差（修改依賴需改動多處）

#### 重構後
```python
def test_example(self, setup_background):
    # 提取依賴（2 行）
    lesson_progress_repository = setup_background["lesson_progress_repository"]
    lesson_service = setup_background["lesson_service"]
    
    # 真正的測試邏輯（5 行）
    progress = LessonProgress(...)
    result = lesson_service.query(...)
    assert result.status == "completed"
```

**行數**: ~7 行（減少 80%）  
**可讀性**: 優（測試邏輯清晰）  
**維護性**: 優（集中管理依賴）

### 重構原則

#### ✅ 應該放在 fixture 的內容
1. **所有測試共用的 repositories 初始化**
2. **所有測試共用的 services 初始化**
3. **Feature-level Background 中的測試數據**（課程、用戶等）
4. **共用的關聯操作**（如訂閱旅程）

#### ❌ 不應該放在 fixture 的內容
1. **測試特定的數據**（如特定進度的 LessonProgress）
2. **測試方法的 Arrange 部分**
3. **會影響其他測試的狀態變更**

### 範例：對比不同測試

#### 測試 1：需要特定進度數據
```python
def test_查詢進行中的課程(self, setup_background):
    # 從 fixture 取得共用依賴
    lesson_progress_repository = setup_background["lesson_progress_repository"]
    lesson_service = setup_background["lesson_service"]
    
    # 建立測試特定的數據（不放在 fixture 中）
    progress = LessonProgress(user_id="Alice", lesson_id=1, progress=70, ...)
    lesson_progress_repository.save(progress)
    
    result = lesson_service.get_lesson_progress(...)
    assert result.progress == 70
```

#### 測試 2：只需要共用數據
```python
def test_查詢未開始的課程(self, setup_background):
    # 從 fixture 取得共用依賴
    lesson_service = setup_background["lesson_service"]
    
    # 不需要額外建立數據，因為 "未開始" 就是沒有 progress 記錄
    # Alice 和課程已在 fixture 中建立
    
    result = lesson_service.get_lesson_progress(user_id="Alice", lesson_id=2)
    assert result.status == "NOT_STARTED"
```

### 重構檢查清單

執行測試程式碼的依賴管理重構時，確認：

- [ ] ✅ 所有測試都使用 `setup_background` fixture
- [ ] ✅ 測試方法只提取需要的依賴（不是全部）
- [ ] ✅ Feature Background 的數據已移到 fixture
- [ ] ✅ 測試特定的數據仍在測試方法中建立
- [ ] ✅ 所有測試仍然通過 🟢
- [ ] ✅ 測試邏輯清晰可讀
- [ ] ✅ 程式碼行數顯著減少

### 統計：重構效益

以 `test_04_查詢課程進度.py` 為例：

| 項目 | 重構前 | 重構後 | 改善 |
|------|--------|--------|------|
| 總行數 | ~375 行 | ~280 行 | -25% |
| 平均測試方法行數 | ~35 行 | ~15 行 | -57% |
| 重複代碼 | 6 處重複 | 0 處重複 | -100% |
| 可讀性 | 中 | 優 | ⬆️ |
| 維護性 | 中 | 優 | ⬆️ |

### 總結

**重構依賴管理的好處**：
1. **消除重複代碼** - DRY 原則
2. **提升可讀性** - 測試邏輯清晰
3. **改善維護性** - 依賴集中管理
4. **加快測試開發** - 減少模板代碼
5. **降低錯誤率** - 統一的初始化邏輯

**核心思想**：
> 讓測試方法專注於「測試什麼」，而非「如何初始化」。

