// 力麗飯店 LineOA CRM 管理後台 - 資料模型 (v0.5.0)
// 根據規格文檔萃取的實體關係模型
// 版本: v0.5.0
// 更新日期: 2026-02-09
// 變更摘要:
//   - v0.5.0: 所有表 PK 統一改為 bigint autoincrement；標記已棄用表；欄位名稱對齊實作
//   - v0.4.5: 移除 AutoResponsePushLog 表及主動推播模式（自動回應僅支援被動觸發）
//   - v0.4.3: ConversationThread / ConversationMessage 表擴展多渠道支援（方案 A：單表 + platform 欄位）
//   - v0.4.3: ConversationThread 新增 member_id / platform / platform_uid / last_message_at 欄位
//   - v0.4.3: ConversationMessage 新增 platform 欄位（冗餘，方便查詢）
//   - v0.4.3: ChatLog 表定位為原始訊息日誌備份，與 ConversationMessage 同時寫入
//   - v0.4.2: Member 表新增 fb_uid/fb_name/fb_avatar、webchat_uid/webchat_name/webchat_avatar 六個欄位（與 LINE 設計一致）
//   - v0.4.1: 新增 FbFriend / WebchatFriend 表（多渠道好友追蹤）
//   - v0.4.0: 新增多渠道整合支援（LINE / Facebook / Webchat）
//   - v0.4.0: 新增 LineChannel 表（多 LINE 頻道管理）
//   - v0.4.0: 新增 FbChannel 表（Facebook 頻道管理）
//   - v0.4.0: 新增 ConversationThread / ConversationMessage 表（對話串整合）
//   - v0.4.0: 新增 ChatLog 表（跨渠道聊天記錄）
//   - v0.4.0: 新增問卷系統（SurveyTemplate / Survey / SurveyQuestion / SurveyResponse）
//   - v0.4.0: 新增 User 表（簡化版使用者管理）
//   - v0.4.0: 新增 TagTriggerLog 表（標籤觸發記錄）
//   - v0.4.0: Member 表新增 gpt_enabled / passport_number / address_detail 欄位
//   - v0.4.0: Message 表新增 platform / source_draft_id 欄位支援多平台發送
//   - v0.4.0: AutoResponse 表新增 channels 欄位支援渠道篩選
//   - v0.3.0: 標籤系統三表架構設計（MemberTag + InteractionTag + MemberInteractionTag）
//   - v0.3.0: MemberTag 表結構更新（移除訊息互動來源，調整欄位為 BigInt PK）
//   - v0.3.0: InteractionTag 表更新（自動產生互動標籤定義，黃色標籤）
//   - v0.3.0: 新增 MemberInteractionTag 表（手動新增互動標籤，藍色標籤）
//   - v0.3.0: 明確定義三種標籤的查詢邏輯和視覺區分
//   - v0.2.1: 新增 LineFriend 表（LINE 好友追蹤實體），用於管理所有加入 LINE 官方帳號的用戶
//   - v0.2.1: 明確定義 LineFriend 與 Member 表的關係（即時雙向同步設計）
//   - v0.2: Messages（群發訊息）與 Campaigns（活動管理）職責清晰分離
//   - v0.2: 新增 MessageDelivery 表（個別會員發送追蹤）
//   - v0.2: MessageTemplate 實施混合儲存策略（DB + CDN）
//   - v0.2: 新增 AutoResponseKeyword、AutoResponseMessage 關聯表
//   - v0.2: 所有 string 欄位定義長度約束
//   - v0.2: 新增 12 組效能索引

// String 欄位長度定義策略：
// 1. 關鍵欄位明確定義長度上限（如 Member.line_uid: 100, Member.name: 32, MemberTag.tag_name: 20）
// 2. 其他一般欄位使用資料庫預設值 TEXT，由資料庫自動管理長度
// 3. 已明確定義長度限制的欄位列表：
//    - Member.line_uid: 100 字元（預留 LINE 格式變更空間）
//    - Member.name: 32 字元（內部識別用）
//    - MemberTag.tag_name: 20 字元（標籤名稱限制）
//    - 其他未明確標註的 string 欄位：使用 TEXT 型別

Table Member {
  id bigint [pk, increment, note: '會員唯一識別碼']
  // LINE 相關資訊
  line_uid string(100) [unique, note: 'LINE 官方帳號會員的唯一識別碼，長度上限 100 字元（當前格式為 U 開頭加 32 位英數字，預留未來 LINE 格式變更空間）']
  line_avatar string(500) [note: 'LINE 會員頭像 CDN URL，上限 500 字元（儲存 LINE 提供的完整 URL，如 https://profile.line-scdn.net/xxxxx），若無頭像或 URL 失效則顯示預設頭像。URL 來源：會員加入時從 LINE Profile API 取得，儲存後不定期更新。前端顯示時直接載入此 URL']
  line_display_name string(100) [note: 'LINE 會員顯示名稱，上限 100 字元']

  // Facebook 相關資訊
  fb_customer_id string(100) [unique, note: 'Facebook User ID，長度上限 100 字元，唯一性約束（NULL 值不受約束）。透過 Facebook OAuth 登入時取得']
  fb_avatar string(500) [note: 'Facebook 會員頭像 URL，上限 500 字元（儲存 Facebook 提供的完整 URL），若無頭像或 URL 失效則顯示預設頭像']
  fb_customer_name string(100) [note: 'Facebook 顯示名稱，上限 100 字元']

  // Webchat 相關資訊
  webchat_uid string(100) [unique, note: 'Webchat 訪客 ID，長度上限 100 字元，唯一性約束（NULL 值不受約束）。系統自動生成或透過 OAuth 關聯取得']
  webchat_avatar string(500) [note: 'Webchat 會員頭像 URL，上限 500 字元，若無頭像則顯示預設頭像']
  webchat_name string(100) [note: 'Webchat 顯示名稱，上限 100 字元']
  name string(32) [note: '會員姓名，供內部人員識別用，上限 32 字元']
  gender string(1) [not null, default: '0', note: '性別（選填），值域：0=不透漏 / 1=男 / 2=女。預設值：0（不透漏）。不允許 NULL。問券蒐集會員性別後產生對應的「男」「女」標籤，性別為「不透漏」（0）則不產生標籤']
  birthday date [note: '生日，格式：yyyy-mm-dd，儲存完整日期（年/月/日）。用途：(1) 生日月份標籤自動生成（系統從完整日期提取月份）、(2) 生日行銷推播、(3) 會員年齡計算。允許 NULL（會員可選擇不提供）']
  email string(255) [unique, note: '電子信箱，上限 255 字元，唯一性約束（NULL 值不受約束），用於會員識別與登入。格式驗證規則：基本 email 格式驗證（必須包含 @ 符號與 . 符號），驗證邏輯：前端與後端 API 皆實施驗證，使用正則表達式 /^[^\s@]+@[^\s@]+\.[^\s@]+$/ 進行格式檢查']
  phone string(20) [note: '手機號碼，上限 20 字元，允許重複（考慮家庭成員共用號碼情境）。格式驗證規則：台灣手機號碼格式（09 開頭 10 碼數字），驗證邏輯：前端與後端使用正則表達式 /^09\d{8}$/ 驗證，允許 NULL（會員可選擇不提供）']
  id_number string(20) [unique, note: '身分證/護照號碼，上限 20 字元（唯一值），用於與 PMS 系統比對。資料保護：明文儲存於資料庫，前端預設顯示遮罩格式（如 A12****789），可手動解除查看完整號碼']
  residence string(100) [note: '居住地，上限 100 字元，值域限制為台灣 22 縣市標準名稱：台北市、新北市、桃園市、台中市、台南市、高雄市、基隆市、新竹市、嘉義市、新竹縣、苗栗縣、彰化縣、南投縣、雲林縣、嘉義縣、屏東縣、宜蘭縣、花蓮縣、台東縣、澎湖縣、金門縣、連江縣。允許 NULL（會員可選擇不提供）']
  join_source string(20) [note: '加入來源，上限 20 字元，採用可擴充設計，支援透過設定檔動態管理來源清單。初始值域：LINE（LINE 官方帳號加入）、CRM（CRM 系統匯入）、PMS（德安 PMS 系統整合）、ERP（ERP 系統整合）、系統（後台手動建立）。未來可透過管理後台或設定檔新增其他來源（如：問券、活動報名等），無需修改程式碼。必填欄位，不允許 NULL']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串（如：2025-01-15T10:30:00Z）。前端顯示時轉換為台灣時區（UTC+8）']
  last_interaction_at timestamp [note: '最後回覆時間（UTC）。更新觸發條件：僅當會員主動發送文字或圖片訊息時更新。不更新情境：被動接收推播訊息、點擊按鈕互動、開啟訊息等行為皆不更新此欄位。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  receive_notification bool [note: '是否接收優惠通知']
  internal_note text [note: '內部人員可新增的備註，用於記錄該會員的消費習慣與喜好。使用 TEXT 型別不限長度']
  passport_number string(50) [note: '護照號碼，上限 50 字元。用於外籍會員識別']
  address_detail string(255) [note: '詳細地址，上限 255 字元。用於配送或寄送用途']
  gpt_enabled bool [default: true, note: '是否啟用 GPT 自動回應。預設值：true。設為 false 時，該會員的訊息不會觸發 GPT 自動回應']
  line_channel_id string(100) [note: 'LINE 頻道 ID，關聯 LineChannel']
  updated_at timestamp [note: '更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  indexes {
    email_index (email) [note: '優化會員 email 搜尋與登入查詢']
    phone_index (phone) [note: '優化會員手機號碼搜尋與 PMS 比對']
    id_number_index (id_number) [note: '優化 PMS 比對關鍵欄位查詢']
    last_interaction_index (last_interaction_at) [note: '優化最近回覆日期排序查詢']
    join_source_index (join_source) [note: '優化會員來源篩選查詢']
    fb_customer_id_index (fb_customer_id) [note: '優化 Facebook UID 查詢（高頻操作）']
    webchat_uid_index (webchat_uid) [note: '優化 Webchat UID 查詢（高頻操作）']
  }

  Note: '''
  會員實體，整合 LINE 官方帳號會員的基本資料與互動行為
  last_interaction_at 更新規則：僅會員主動發送訊息時更新，被動接收推播訊息或點擊按鈕不更新此欄位，用於判斷會員主動互動活躍度

  效能優化索引：
    - email_index：會員搜尋、登入驗證（高頻操作）
    - phone_index：會員搜尋、PMS 系統比對
    - id_number_index：PMS 系統比對關鍵欄位
    - last_interaction_index：「最近回覆日期」排序查詢，支援 24 小時內需回覆會員篩選
    - join_source_index：來源篩選統計

  關係：Member 1:N MemberTag, Member 1:N MemberInteractionRecord, Member 1:N MessageRecord, Member 1:N ConsumptionRecord, Member 1:N MessageDelivery

  LineFriend 同步策略：
    - 共同欄位對應：Member.line_uid ↔ LineFriend.line_uid、Member.line_name ↔ LineFriend.line_display_name、Member.line_avatar ↔ LineFriend.line_picture_url
    - FollowEvent（好友加入）：
        * 依 line_uid 建立或更新 LineFriend 後，系統 upsert Member
        * 若 Member 不存在：建立新 Member，預設 join_source = 'LINE'，同步寫入 line_name 與 line_avatar
        * 若 Member 已存在：更新 line_name、line_avatar、last_interaction_at，保留其他欄位
    - LINE Profile 同步為強制雙向：任一表的 line_name/line_avatar（或 line_display_name/line_picture_url）變更時，立即寫回另一表，並在同一交易內保持兩邊欄位一致（尚未關聯時僅更新現有表，不進行延遲同步）
    - LineFriend.member_id 維持與 Member.member_id 的參照，雙向同步時需同時更新
  '''
}

Table LineFriend [note: 'DEPRECATED - 僅在 line_app 中以 raw SQL 管理，無 SQLAlchemy model'] {
  id bigint [pk, increment, note: 'LINE 好友唯一識別碼']
  line_uid string(100) [unique, not null, note: 'LINE User ID，唯一性約束。格式：U 開頭加 32 位英數字（如 U1234567890abcdef1234567890abcdef）']
  member_id bigint [ref: > Member.id, note: '關聯的會員 ID（選填）。填寫問卷成為會員後建立關聯，未填寫問卷則為 NULL']
  line_display_name string(100) [note: 'LINE 顯示名稱，從 LINE Profile API 取得，上限 100 字元']
  line_picture_url string(500) [note: 'LINE 頭像 URL，從 LINE Profile API 取得（如 https://profile.line-scdn.net/xxxxx），上限 500 字元']
  is_following bool [note: '是否追蹤中：true 為當前好友 / false 為已取消追蹤。預設值：true']
  followed_at timestamp [note: '首次加好友時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。前端顯示時轉換為台灣時區（UTC+8）']
  unfollowed_at timestamp [note: '取消追蹤時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。允許 NULL（未取消追蹤）']
  last_interaction_at timestamp [note: '最後互動時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。每次用戶互動（發訊息、postback、圖片等）都更新此欄位']
  profile_updated_at timestamp [note: 'LINE Profile 最近一次同步時間（UTC）。用於判斷是否需重新呼叫 LINE Profile API']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。on update CURRENT_TIMESTAMP']

  indexes {
    line_uid_index (line_uid) [note: '優化 LINE UID 查詢（高頻操作），每次互動都需查詢']
    member_id_index (member_id) [note: '優化會員關聯查詢，支援 JOIN 操作']
    is_following_index (is_following) [note: '優化好友狀態篩選查詢（如：篩選當前好友）']
    last_interaction_index (last_interaction_at) [note: '優化最近互動時間排序查詢，支援活躍度分析']
  }

  Note: '''
  LINE 好友追蹤實體，用於管理所有加入 LINE 官方帳號的用戶

  核心功能：
    1. 追蹤 LINE 好友狀態（加入好友、取消追蹤、重新加好友）
    2. 儲存最新 LINE Profile（displayName, pictureUrl）
    3. 記錄好友互動時間與頻率
    4. 與會員系統建立可選關聯

  與 Member 表的關係與同步：
    - FollowEvent：建立或更新 LineFriend 後，同步 upsert Member；若 Member 不存在則建立 join_source = LINE 的記錄，若存在則更新 line_name、line_avatar
    - LineFriend.member_id 於 upsert 後回寫，維持 referential integrity
    - 任一方（LineFriend 或 Member）line 名稱 / 頭像更新時，必須在同一交易內更新另一方。未關聯（member_id = NULL）前僅更新 LineFriend；關聯建立後強制保持一致
    - 非 LINE 來源的 Member 可無對應 LineFriend；LineFriend 仍可為 NULL member_id 直到關聯完成

  Profile 同步策略：
    - 加好友時（FollowEvent）：立即呼叫 LINE Profile API 取得 displayName 和 pictureUrl
    - 後續互動時：僅在首次互動時補抓取（若 line_display_name 或 line_picture_url 為空）
    - 每次呼叫成功後更新 line_display_name、line_picture_url 與 profile_updated_at
    - profile_updated_at 欄位保留用於記錄最後更新時間，但不實作定期自動更新排程
    - 錯誤處理：API 失敗時靜默失敗，記錄 log，不中斷主流程
    - **實作決策**：不實作 30 天定期頭像更新排程（詳見 implementation_decisions.md）

  好友狀態管理：
    - 加好友（FollowEvent）：
      * is_following = true
      * followed_at = 當前時間
      * unfollowed_at = NULL
    - 取消追蹤（UnfollowEvent）：
      * is_following = false
      * unfollowed_at = 當前時間
    - 重新加好友：
      * is_following = true
      * followed_at = 當前時間（更新為最新加好友時間）
      * unfollowed_at = NULL（清除取消追蹤記錄）

  互動時間更新：
    - 更新觸發：每次用戶主動互動（發訊息、點擊按鈕、發送圖片等）
    - 更新欄位：last_interaction_at = 當前時間
    - 用途：追蹤用戶活躍度、計算沉默用戶、支援再行銷策略

  會員關聯邏輯：
    - 用戶加好友 → 建立 LineFriend 記錄（member_id = NULL）
    - 用戶填寫問卷 → 建立 Member 記錄
    - 系統關聯 → 更新 LineFriend.member_id = Member.member_id
    - 比對方式：透過 LINE UID 比對（LineFriend.line_uid = Member.line_uid）
    - 關聯時機：問卷填寫完成後、手動匯入會員資料時

  索引優化：
    - line_uid_index：高頻查詢優化（每次互動都需要根據 LINE UID 查詢），提升查詢速度 80%+
    - member_id_index：會員關聯查詢優化，支援 JOIN Member 表操作
    - is_following_index：快速篩選當前好友（如：群發訊息目標對象篩選）
    - last_interaction_index：按互動時間排序（如：找出 30 天未互動的沉默用戶）

  資料保留策略：
    - 所有 LineFriend 記錄永久保留，不自動刪除（包含已取消追蹤超過 90 天者）
    - is_following + followed_at/unfollowed_at 作為歷史軌跡來源，供風險稽核、再行銷與活動分析
    - 即使尚未關聯 Member 也保留原始紀錄；若後續建立會員關聯，可回溯歷史好友狀態

  效能優化索引：
    - line_uid_index：每次互動必查（< 10ms）
    - member_id_index：會員系統聯查（< 50ms）
    - is_following_index：好友篩選（< 100ms）
    - last_interaction_index：活躍度分析（< 200ms）

  關係：LineFriend N:1 Member（可選關聯，允許 NULL）
  '''
}

Table FbFriend [note: 'DEPRECATED - 僅在 chatroom_multichannel_mock.py 中，無 SQLAlchemy model'] {
  id bigint [pk, increment, note: 'Facebook 好友唯一識別碼']
  fb_uid string(100) [unique, not null, note: 'Facebook User ID，唯一性約束']
  member_id bigint [ref: > Member.id, note: '關聯的會員 ID（選填）。OAuth 授權成為會員後建立關聯，未授權則為 NULL']
  fb_display_name string(255) [note: 'Facebook 顯示名稱，從 Facebook Graph API 取得，上限 255 字元']
  fb_picture_url string(500) [note: 'Facebook 頭像 URL，從 Facebook Graph API 取得，上限 500 字元']
  email string(255) [note: 'Facebook 授權取得的 email，用於跨渠道會員比對']
  is_following bool [not null, default: true, note: '是否追蹤中：true 為當前好友 / false 為已取消追蹤。預設值：true']
  followed_at timestamp [note: '首次加好友時間（UTC）']
  unfollowed_at timestamp [note: '取消追蹤時間（UTC）。允許 NULL（未取消追蹤）']
  last_interaction_at timestamp [note: '最後互動時間（UTC）。每次用戶互動（發訊息、postback 等）都更新此欄位']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）。on update CURRENT_TIMESTAMP']

  indexes {
    fb_uid_index (fb_uid) [note: '優化 FB UID 查詢（高頻操作）']
    member_id_index (member_id) [note: '優化會員關聯查詢，支援 JOIN 操作']
    is_following_index (is_following) [note: '優化好友狀態篩選查詢']
    last_interaction_index (last_interaction_at) [note: '優化最近互動時間排序查詢']
  }

  Note: '''
  Facebook 好友追蹤實體，用於管理所有透過 Facebook Messenger 互動的用戶

  核心功能：
    1. 追蹤 Facebook 好友狀態（連結、取消連結）
    2. 儲存 Facebook Profile（displayName, pictureUrl, email）
    3. 記錄好友互動時間與頻率
    4. 與會員系統建立可選關聯（透過 email 或 OAuth）

  與 Member 表的關係與同步（雙向同步設計）：
    - OAuth 授權事件：建立或更新 FbFriend 後，同步 upsert Member；若 Member 不存在則建立 join_source = Facebook 的記錄，若存在則更新相關欄位
    - FbFriend.member_id 於 upsert 後回寫，維持 referential integrity
    - 任一方（FbFriend 或 Member）名稱 / 頭像 / email 更新時，必須在同一交易內更新另一方。未關聯（member_id = NULL）前僅更新 FbFriend；關聯建立後強制保持一致
    - 非 Facebook 來源的 Member 可無對應 FbFriend；FbFriend 仍可為 NULL member_id 直到關聯完成
    - 透過 email 比對進行跨渠道會員合併

  好友狀態管理：
    - 連結（OAuth 授權）：
      * is_following = true
      * followed_at = 當前時間
      * unfollowed_at = NULL
    - 取消連結：
      * is_following = false
      * unfollowed_at = 當前時間
    - 重新連結：
      * is_following = true
      * followed_at = 當前時間（更新為最新連結時間）
      * unfollowed_at = NULL（清除取消連結記錄）

  互動時間更新：
    - 更新觸發：每次用戶主動互動（發訊息、點擊按鈕等）
    - 更新欄位：last_interaction_at = 當前時間
    - 用途：追蹤用戶活躍度、計算沉默用戶、支援再行銷策略

  資料保留策略：
    - 所有 FbFriend 記錄永久保留，不自動刪除
    - is_following + followed_at/unfollowed_at 作為歷史軌跡來源

  關係：FbFriend N:1 Member（可選關聯，允許 NULL）
  '''
}

Table WebchatFriend [note: 'DEPRECATED - 僅在 chatroom_multichannel_mock.py 中，無 SQLAlchemy model'] {
  id bigint [pk, increment, note: 'Webchat 訪客唯一識別碼']
  webchat_uid string(100) [unique, not null, note: 'Webchat 訪客 ID，唯一性約束。格式：UUID v4（如 550e8400-e29b-41d4-a716-446655440000）。生成時機：訪客首次連線時由後端生成，儲存於 localStorage 供重新訪問時識別']
  member_id bigint [ref: > Member.id, note: '關聯的會員 ID（選填）。OAuth 授權成為會員後建立關聯']
  webchat_display_name string(100) [note: 'Webchat 顯示名稱，上限 100 字元']
  webchat_picture_url string(500) [note: 'Webchat 頭像 URL，上限 500 字元']
  email string(255) [note: 'OAuth 授權取得的 email，用於跨渠道會員比對']
  is_following bool [not null, default: true, note: '是否活躍中：true 為活躍訪客 / false 為已結束會話。預設值：true。會話結束判定：WebSocket 連線斷開時（瀏覽器關閉或網路中斷）自動設為 false']
  followed_at timestamp [note: '首次訪問時間（UTC）']
  unfollowed_at timestamp [note: '會話結束時間（UTC）。允許 NULL（活躍中）']
  last_interaction_at timestamp [note: '最後互動時間（UTC）。每次用戶互動都更新此欄位']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）。on update CURRENT_TIMESTAMP']

  indexes {
    webchat_uid_index (webchat_uid) [note: '優化 Webchat UID 查詢（高頻操作）']
    member_id_index (member_id) [note: '優化會員關聯查詢，支援 JOIN 操作']
    is_following_index (is_following) [note: '優化訪客狀態篩選查詢']
    last_interaction_index (last_interaction_at) [note: '優化最近互動時間排序查詢']
  }

  Note: '''
  Webchat 訪客追蹤實體，用於管理所有透過 Webchat 互動的訪客

  核心功能：
    1. 追蹤 Webchat 訪客會話狀態
    2. 儲存訪客資訊（displayName, pictureUrl, email）
    3. 記錄訪客互動時間與頻率
    4. 與會員系統建立可選關聯（透過 OAuth 或 email 比對）

  與 Member 表的關係與同步（雙向同步設計）：
    - 訪客互動事件：建立或更新 WebchatFriend 後，同步 upsert Member；若 Member 不存在則建立 join_source = Webchat 的記錄，若存在則更新相關欄位
    - WebchatFriend.member_id 於 upsert 後回寫，維持 referential integrity
    - 任一方（WebchatFriend 或 Member）名稱 / 頭像 / email 更新時，必須在同一交易內更新另一方。未關聯（member_id = NULL）前僅更新 WebchatFriend；關聯建立後強制保持一致
    - 非 Webchat 來源的 Member 可無對應 WebchatFriend；WebchatFriend 仍可為 NULL member_id 直到關聯完成
    - Webchat 訪客可透過 LINE / Facebook / Google OAuth 登入後關聯既有會員
    - 跨渠道會員合併觸發時機：OAuth 登入成功後依混合策略即時合併
      * 合併優先順序：
        1. email 相同 → 合併為同一 member_id
        2. 同渠道 UID 已存在 → 使用既有 member_id（同一用戶重複登入）
        3. 以上都不符合 → 建立新 member_id
      * 延遲合併：若 OAuth 未取得 email，日後用戶填入 email 時再觸發合併
      * 合併策略：新資料優先覆蓋非空欄位，空白不覆蓋舊資料
      * 標籤合併：去重合併集合

  webchat_uid 生成規則：
    - 格式：UUID v4（36 字元，如 550e8400-e29b-41d4-a716-446655440000）
    - 生成時機：訪客首次建立 WebSocket 連線時由後端生成
    - 唯一性保證：UUID v4 碰撞機率極低（2^122 可能值），無需額外檢查
    - 跨 session 識別：
      * 前端將 webchat_uid 儲存於 localStorage
      * 訪客重新訪問時優先讀取既有 ID
      * 若 localStorage 無資料或被清除，視為新訪客並生成新 UUID
    - 與 OAuth 整合：OAuth 登入前使用 UUID 追蹤，登入後透過 email 與會員關聯

  訪客狀態管理：
    - 首次訪問：
      * is_following = true
      * followed_at = 當前時間
      * unfollowed_at = NULL
    - 會話結束（WebSocket 斷線偵測）：
      * 偵測方式：WebSocket 連線斷開（瀏覽器關閉、網路中斷、手動離開）
      * 心跳機制：每 30 秒 ping/pong 確認連線狀態
      * 重連寬限期：60 秒內重新連線視為同一會話，不更新狀態
      * is_following = false
      * unfollowed_at = 當前時間
    - 重新訪問：
      * is_following = true
      * followed_at = 當前時間（更新為最新訪問時間）
      * unfollowed_at = NULL（清除結束記錄）

  互動時間更新：
    - 更新觸發：每次用戶主動互動（發訊息、點擊按鈕等）
    - 更新欄位：last_interaction_at = 當前時間
    - 用途：追蹤用戶活躍度、計算沉默用戶、支援再行銷策略

  資料保留策略：
    - 所有 WebchatFriend 記錄永久保留，不自動刪除
    - is_following + followed_at/unfollowed_at 作為歷史軌跡來源

  關係：WebchatFriend N:1 Member（可選關聯，允許 NULL）
  '''
}

Table MemberTag {
  id bigint [pk, increment, note: '會員標籤唯一識別碼']
  member_id bigint [ref: > Member.id, not null, note: '所屬會員 ID']
  tag_name string(20) [not null, note: '標籤名稱，不得超過 20 個字元（中英文皆計算，每個字元計 1）。格式限制：僅允許中文（\u4e00-\u9fa5）、英文（a-zA-Z）、數字（0-9）、空格，禁止特殊字元與 Emoji。驗證：前端使用正則表達式 /^[\u4e00-\u9fa5a-zA-Z0-9\s]+$/ 即時驗證']
  tag_source string(20) [note: '標籤來源，上限 20 字元：CRM / PMS / 問券 / 後台自訂（不包含訊息互動，訊息互動標籤使用 InteractionTag 和 MemberInteractionTag）']
  trigger_count int [default: 0, note: '觸發次數（保留欄位，用於統計），>= 0']
  trigger_member_count int [default: 0, note: '觸發會員數（保留欄位，用於統計），>= 0']
  last_triggered_at timestamp [note: '最近觸發時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  message_id bigint [note: '觸發來源訊息 ID（用於去重判斷）。非訊息來源時為 NULL']
  click_count int [not null, default: 1, note: '點擊次數，>= 1。預設值：1（首次點擊）。重複點擊同一組合時執行 UPDATE click_count = click_count + 1，累計點擊次數不去重']
  tagged_at timestamp [default: `now()`, note: '標記時間（UTC）']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）。on update CURRENT_TIMESTAMP']

  indexes {
    member_id_index (member_id) [note: '優化會員標籤查詢']
    tag_name_index (tag_name) [note: '優化標籤名稱查詢']
    unique_member_tag_message [unique, note: '確保 (member_id, tag_name, message_id) 組合唯一性，防止重複插入'] (member_id, tag_name, message_id)
  }

  Note: '''
  會員標籤實體（單表設計），用於標記會員屬性或消費行為

  標籤來源（4種）：
    1. 外部系統串接（CRM/PMS）：消費金額達門檻、房型分類、訪問頻率、上次互動時間
    2. 問券蒐集：性別、年齡區間、地區、生日月份
    3. 後台自訂：VIP、黑名單等自訂標籤
    4. ❌ 訊息互動：已移至 InteractionTag 和 MemberInteractionTag 表

  架構變更說明（v2 設計）：
    - v1 設計：MemberTag 統一處理所有標籤（包含訊息互動）
    - v2 設計：MemberTag 僅處理會員標籤，訊息互動標籤分離至 InteractionTag 和 MemberInteractionTag
    - 變更原因：
      * 前端需要區分自動產生（黃色）和手動新增（藍色）的互動標籤
      * 自動產生的互動標籤透過 ComponentInteractionLog 關聯查詢
      * 手動新增的互動標籤直接關聯會員，便於管理

  去重邏輯：
    - UNIQUE 索引 (member_id, tag_name, message_id) 確保唯一性
    - 相同會員、相同標籤、相同來源（message_id）只有一筆記錄
    - message_id 為 NULL 時，同一會員同一標籤只有一筆記錄
    - MemberTag 與 InteractionTag 可同名；對同一會員顯示時，按 tag_name 去重合併來源（會員標籤 + 自動互動 + 手動互動），前端以標籤類型樣式區分

  message_id 填值策略：
    - 後台手動新增/移除：message_id = NULL
    - CRM 系統同步：message_id = NULL（或使用固定識別碼）
    - PMS 系統同步：message_id = NULL（或使用固定識別碼）
    - 問券蒐集：message_id = NULL（或使用 survey_id）

  API 端點：
    - 查詢會員標籤：GET /api/v1/members/{id} → 包含 tags 陣列（僅會員標籤）
    - 批量更新會員標籤：PUT /api/v1/members/{id}/tags → 完全取代現有標籤
    - 標籤列表：GET /api/v1/tags?type=member

  查詢邏輯（會員詳情頁）：
    - 查詢順序：MemberTag → InteractionTag (auto) → MemberInteractionTag (manual)
    - 合併去重：按 tag_name 去重，合併來源（會員標籤/互動標籤），優先顯示最早建立的記錄
    - 視覺區分：會員標籤（綠色）、自動互動標籤（黃色）、手動互動標籤（藍色）

  資料完整性：
    - ON DELETE CASCADE：刪除會員時自動刪除關聯標籤
    - 標籤名稱驗證：前後端雙重驗證，確保格式正確

  關係：MemberTag N:1 Member
  '''
}

Table TagRule {
  id bigint [pk, increment, note: '規則唯一識別碼']
  tag_name string(20) [note: '標籤名稱（如：高消費客戶、常客），上限 20 字元']
  tag_source string(20) [note: '標籤來源，上限 20 字元：CRM / PMS / 問券 / 後台自訂 / LINE互動。必填欄位']
  rule_type string(30) [note: '規則類型，上限 30 字元：consumption_amount（消費金額）/ visit_frequency（訪問頻率）/ interaction_time（互動時間）/ room_type（房型分類）。必填欄位']
  threshold_value float [note: '門檻值（如：30000 元、3 次）。小數精度限制：僅接受整數值，不支援小數（驗證邏輯：前端輸入欄位設定 step=1，後端 API 驗證值為整數）。允許 NULL（房型分類不需要門檻值）']
  threshold_unit string(10) [note: '單位，上限 10 字元：NTD（新台幣）/ times（次）/ days（天）。允許 NULL（房型分類不需要單位）']
  period_days int [note: '計算週期（天數），如 365 表示滾動 12 個月。允許 NULL（互動時間規則不需要週期）']
  condition_operator string(5) [note: '比較運算子，上限 5 字元：>= / > / <= / < / =。預設值：>=']
  is_enabled bool [note: '是否啟用。預設值：true']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  last_executed_at timestamp [note: '最後執行時間（UTC）。記錄管理員最近一次手動執行此規則的時間。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。允許 NULL（尚未執行過的規則）']

  Note: '''
  標籤規則實體，用於定義 CRM/PMS 標籤的自動生成規則
  執行策略：標籤規則採用手動執行策略，規則建立或啟用後不會自動執行，需管理員手動點擊「執行規則」按鈕才會執行
  執行記錄：每次執行後更新 last_executed_at 欄位，可透過此欄位追蹤規則最後執行時間
  規則類型說明：
    - consumption_amount：消費金額達門檻（如：過去 12 個月消費 >= 30000 元）
    - visit_frequency：訪問頻率達門檻（如：過去 12 個月住宿 >= 3 次）
    - interaction_time：互動時間超過門檻（如：超過 60 天未主動互動）
    - room_type：房型分類（如：雙人房、商務房）
  計算週期：採用滾動時間窗口（從當前日期往前推算 period_days 天）
  規則管理：透過後台管理介面進行 CRUD 操作，修改立即生效
  規則驗證：門檻值必須為正數，計算週期建議不超過 730 天（2 年）
  執行審計：手動執行時需記錄操作人員、規則名稱、影響會員數與時間，供稽核查詢；日後若導入排程將另行定義
  '''
}

Table ClickTrackingDemo {
  id int [pk, increment, note: '主鍵']
  line_id string [not null, note: 'LINE 用戶 UID（最大長度 64）']
  source_campaign_id int [not null, default: 0, note: '來源活動 ID']
  line_display_name string [note: 'LINE 顯示名稱（最大長度 128）']
  total_clicks int [not null, default: 0, note: '總點擊次數（32 位元 int，上限 2,147,483,647，足以覆蓋單用戶單活動的累積點擊量）']
  last_clicked_at timestamp [note: '最後點擊時間']
  last_click_tag string [note: '最後點擊的標籤（逗號分隔，如「優惠,萬聖節」）']
  created_at timestamp [not null, default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [not null, default: `now()`, note: '更新時間（UTC）']

  indexes {
    (line_id, source_campaign_id) [unique, name: 'uq_line_source_campaign', note: '同一用戶對同一活動僅一筆統計記錄']
    source_campaign_id [name: 'idx_source_campaign']
  }

  Note: '''
  點擊追蹤統計表，用於記錄用戶對特定活動的點擊統計
  統計維度：以「用戶 + 活動」為維度進行統計
  統計邏輯：
    - total_clicks：該用戶對該活動的總點擊次數（目前實作固定為 1）
    - last_click_tag：標籤合併邏輯，保留既有順序，新標籤依序追加
    - 範例：用戶A點擊活動1（標籤：優惠）、用戶B點擊活動1（標籤：萬聖節）→ 各自一筆記錄
  關係：ClickTrackingDemo 關聯查詢 Member（透過 line_id）
  資料來源：/__track 路由處理點擊事件時更新
  '''
}

Table InteractionTag {
  id bigint [pk, increment, note: '互動標籤唯一識別碼']
  tag_name string(20) [not null, note: '標籤名稱，不得超過 20 個字元（中英文皆計算，每個字元計 1）。格式限制：僅允許中文（\u4e00-\u9fa5）、英文（a-zA-Z）、數字（0-9）、空格，禁止特殊字元與 Emoji。驗證：前端使用正則表達式 /^[\u4e00-\u9fa5a-zA-Z0-9\s]+$/ 即時驗證']
  tag_source string(20) [note: '標籤來源：訊息模板 / 問券模板']
  trigger_count int [default: 0, note: '觸發次數，累計所有不重複的 (line_id, tag_id, message_id) 組合數，>= 0。計算邏輯：COUNT(DISTINCT ComponentInteractionLog)，同一會員點擊不同訊息會累計，點擊相同訊息不重複計算']
  trigger_member_count int [default: 0, note: '觸發會員數，不重複會員總數，>= 0。計算邏輯：COUNT(DISTINCT line_id FROM ComponentInteractionLog)，同一會員無論點擊多少次或多少訊息，僅計算一次']
  last_triggered_at timestamp [note: '最近觸發時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）。on update CURRENT_TIMESTAMP']

  indexes {
    tag_name_index (tag_name) [note: '優化標籤名稱查詢']
  }

  Note: '''
  互動標籤定義實體，用於定義可用的互動標籤（自動產生類型）

  產生方式：
    - 訊息模板設定：當訊息模板中定義了互動標籤時，系統自動建立 InteractionTag 定義
    - 問券模板設定：問券模板中定義的互動標籤也會自動建立定義

  觸發方式：
    - 會員點擊訊息按鈕時，系統記錄到 ComponentInteractionLog 表
    - 透過 ComponentInteractionLog 關聯，可查詢哪些會員觸發了此標籤

  統計邏輯：
    - trigger_count：累計所有觸發記錄（以 ComponentInteractionLog 唯一記錄為基準）
    - trigger_member_count：不重複會員數（同一會員多次觸發僅計一次）
    - 範例：會員A點擊訊息1、訊息2，會員B點擊訊息1 → trigger_count=3, trigger_member_count=2

  視覺呈現：
    - 前端顯示為黃色標籤（表示自動產生）
    - 通過 source='auto' 區分

  與 MemberInteractionTag 的區別：
    - InteractionTag：自動產生，通過訊息互動觸發，查詢需 JOIN ComponentInteractionLog
    - MemberInteractionTag：手動新增，CRM 管理員直接為會員打標籤，直接關聯會員

  關係：InteractionTag 1:N ComponentInteractionLog
  '''
}

Table MemberInteractionTag {
  id bigint [pk, increment, note: '會員互動標籤唯一識別碼']
  member_id bigint [ref: > Member.id, not null, note: '所屬會員 ID']
  tag_name string(20) [not null, note: '標籤名稱，不得超過 20 個字元（中英文皆計算，每個字元計 1）。格式限制：僅允許中文（\u4e00-\u9fa5）、英文（a-zA-Z）、數字（0-9）、空格，禁止特殊字元與 Emoji。驗證：前端使用正則表達式 /^[\u4e00-\u9fa5a-zA-Z0-9\s]+$/ 即時驗證']
  tag_source string(20) [default: 'CRM', note: '標籤來源：固定為 CRM（手動新增）']
  trigger_count int [default: 0, note: '觸發次數（保留欄位，手動標籤固定為 0）']
  trigger_member_count int [default: 0, note: '觸發會員數（保留欄位，手動標籤固定為 0）']
  last_triggered_at timestamp [note: '最近觸發時間（保留欄位，手動標籤為 NULL）']
  message_id bigint [note: '觸發來源訊息 ID（用於去重，手動新增時為 NULL）']
  click_count int [not null, default: 1, note: '點擊次數，>= 1。預設值：1（首次點擊）。手動標籤此欄位固定為 1，不累加']
  tagged_at timestamp [default: `now()`, note: '標記時間（UTC）']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）。on update CURRENT_TIMESTAMP']

  indexes {
    member_id_index (member_id) [note: '優化會員標籤查詢']
    unique_member_tag_message [unique, note: '確保 (member_id, tag_name, message_id) 組合唯一性'] (member_id, tag_name, message_id)
  }

  Note: '''
  會員互動標籤實體（手動新增類型），用於 CRM 管理員手動為會員打互動標籤

  用途：
    - CRM 管理員在會員詳情頁手動新增互動標籤
    - 與自動產生的 InteractionTag 區分開來
    - 直接關聯會員，無需透過 ComponentInteractionLog

  新增方式：
    - API 端點：PUT /api/v1/members/{member_id}/interaction-tags
    - 管理員在前端標籤編輯器中選擇互動標籤並儲存
    - 系統自動建立 MemberInteractionTag 記錄

  去重邏輯：
    - UNIQUE 索引 (member_id, tag_name, message_id) 確保唯一性
    - 手動新增時 message_id 為 NULL，因此同一會員同一標籤只有一筆記錄
    - 若未來支援從訊息模板手動打標籤，message_id 將記錄來源訊息

  視覺呈現：
    - 前端顯示為藍色標籤（表示手動新增）
    - 通過 source='manual' 區分

  與 InteractionTag 的區別：
    - MemberInteractionTag：手動新增，CRM 管理員直接為會員打標籤，直接關聯會員
    - InteractionTag：自動產生，通過訊息互動觸發，查詢需 JOIN ComponentInteractionLog

  資料完整性：
    - ON DELETE CASCADE：刪除會員時自動刪除關聯標籤
    - tag_source 固定為 'CRM'，標示為手動新增

  關係：MemberInteractionTag N:1 Member
  '''
}

Table ComponentInteractionLog {
  id bigint [pk, increment, note: '主鍵']
  line_id string [not null, note: 'LINE 用戶 UID（最大長度 100）']
  message_id bigint [not null, note: '群發訊息 ID（對應 messages.id）']
  campaign_id bigint [note: '活動 ID（選填，對應 campaigns.id）']
  template_id bigint [note: '模板 ID（對應 message_templates.id）']
  carousel_item_id bigint [note: '輪播圖卡片 ID（對應 template_carousel_items.id）']
  interaction_tag_id bigint [note: '互動標籤 ID（對應 interaction_tags.id）']
  component_slot string [note: '模板元件槽位（最大長度 50）']
  interaction_type string [not null, note: '互動類型：button_url（按鈕網址）']
  interaction_value text [note: '互動值（如 URL、訊息內容等）']
  triggered_at timestamp [not null, default: `now()`, note: '觸發時間（UTC）']
  line_event_type string [note: 'LINE 事件類型（最大長度 50）']
  user_agent text [note: '用戶代理']

  indexes {
    line_id [name: 'idx_line_id']
    message_id [name: 'idx_message_id']
    campaign_id [name: 'idx_campaign_id']
    template_id [name: 'idx_template_id']
    carousel_item_id [name: 'idx_carousel_item_id']
    interaction_tag_id [name: 'idx_interaction_tag_id']
    component_slot [name: 'idx_component_slot']
    interaction_type [name: 'idx_interaction_type']
    triggered_at [name: 'idx_triggered_at']
  }

  Note: '''
  元件互動記錄表，用於追蹤會員與訊息元件的詳細互動行為
  記錄策略：每次互動都記錄一筆，不進行去重（完整的互動歷史）
  關聯維度：line_id（用戶識別）、message_id（群發訊息）、campaign_id（活動）、template_id（訊息模板）、carousel_item_id（輪播圖卡片）、interaction_tag_id（互動標籤）、component_slot（元件位置）
  資料來源：/__track 路由處理點擊事件時插入記錄
  '''
}

Table Message {
  id bigint [pk, increment, note: '訊息唯一識別碼']
  campaign_id bigint [ref: > Campaign.id, note: '所屬活動ID（選填）。若此訊息屬於特定行銷活動，關聯至 Campaign；若為獨立訊息則為 NULL']
  template_id bigint [ref: > MessageTemplate.id, note: '使用的訊息模板ID']
  send_time timestamp [note: '實際傳送時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。前端顯示時轉換為台灣時區（UTC+8）']
  send_count int [note: '傳送人數，>= 0']
  message_title string(500) [note: '訊息標題（用於列表顯示），上限 500 字元']
  open_count int [note: '開啟次數（會員已讀訊息的不重複人數），>= 0。計算邏輯：COUNT(DISTINCT member_id WHERE 已讀)']
  send_status string(20) [note: '發送狀態：draft（草稿）/ scheduled（排程發送）/ sending（發送中）/ sent（已發送）/ failed（發送失敗）。狀態轉換規則：draft ⇄ scheduled → sending → sent（終止）/ failed → draft（可修改重試）。sending 為過渡狀態，表示系統正在執行發送作業；sent 為終止狀態不可變更；failed 後可改回 draft 修正問題並重新排程。重試策略：僅支援手動重試，不提供自動重試機制。失敗處理流程：(1) 系統記錄失敗原因到 failure_reason 欄位、(2) 狀態改為 failed、(3) 管理員檢視失敗原因並決定處理方式、(4) 手動將狀態改回 draft、(5) 修正問題（如確認配額充足、修改訊息內容）後重新排程發送']

  Note: '''
  點擊次數統計說明：
    - 點擊數據不再作為 messages 表的欄位儲存，改為從 ComponentInteractionLog 動態計算
    - 計算邏輯：COUNT(DISTINCT line_id WHERE message_id = ? AND interaction_type = 'button_url')
    - 統計來源：/__track 路由記錄的 component_interaction_logs 資料
    - 支援多維度分析：可按 template_id、campaign_id、interaction_tag_id 等維度聚合統計
  '''
  failure_reason string(500) [note: '發送失敗原因（如：訊息額度不足），上限 500 字元，允許 NULL']
  target_type string(20) [note: '傳送對象類型：all_friends（所有好友）/ filtered（篩選目標對象）']
  target_filter text [note: '篩選條件（若為篩選目標對象），JSON 格式儲存。支援邏輯：包含條件（多個標籤全部 AND）或排除條件（多個標籤全部 AND NOT）。前端以 include/exclude 切換開關實作互斥模式，送出的 target_filter 僅會包含其中一種陣列，避免同時 include 與 exclude 或兩者皆空。範例：{"include": ["VIP", "台北市"]} 表示必須同時包含 VIP 與 台北市；{"exclude": ["黑名單"]} 表示排除黑名單成員']
  scheduled_datetime_utc timestamp [note: '排程發送時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串（如：2025-02-01T02:00:00Z）。範例：2025-02-01T02:00:00Z 表示台灣時間 2025/02/01 10:00。前端顯示時轉換為台灣時區（UTC+8，固定偏移無夏令時）。若為立即發送則此欄位為 NULL']
  trigger_condition text [note: '特定觸發條件（預留欄位，v0 版不實作，允許 NULL）。未來可能用途：動態條件篩選（如：加入好友 7-29 天、最後互動超過 30 天）。建議未來使用 JSON 格式（如：{"type":"join_duration","min_days":7,"max_days":29}）。v0 版使用標籤系統實現相同需求']
  estimated_send_count int [note: '預計發送好友人數，>= 0。計算時機：發送前根據篩選條件（target_filter）計算符合條件的會員數量。計算邏輯：依 platform 計算：LINE → 查詢 LineFriend is_following=true；Facebook → 查詢 FbFriend is_following=true（若有）；Instagram → 查詢對應好友表。每次發送前即時計算，不長存']
  available_quota int [note: '可用訊息配額餘額，>= 0。資料來源依 platform 而定：LINE → 即時呼叫 LINE Messaging API quota endpoint 並同步更新；Facebook/Instagram：若平台無配額或無配額 API，則 available_quota 設為 NULL 並視為「無限額」且不阻擋發送（僅記錄狀態），若未來提供配額 API，改為同樣即時查詢與驗證']
  thumbnail string(500) [note: '縮圖 URL，上限 500 字元，無圖片則為系統預設圖']
  flex_message_json text [note: 'Flex Message JSON 內容（選填），由前端 Flex Message Simulator 產生。後端驗證：(1) JSON 格式正確性（可解析）、(2) 基本結構完整性。前端使用 LINE 官方 Simulator 確保符合 LINE Flex Message 規範']
  platform string(20) [default: 'LINE', note: '發送平台：LINE / Facebook；Instagram 暫不支援且不允許選取。預設值：LINE。未來若加入 Instagram，需補齊好友表、配額查詢與投遞管線後再開放']
  source_draft_id bigint [ref: > Message.id, note: '來源草稿 ID。當訊息從草稿發布時，記錄原始草稿的 message_id，用於追蹤訊息來源']
  notification_message string(200) [note: '通知推播訊息，上限 200 字元。顯示在手機通知欄的文字內容']
  fb_message_json text [note: 'Facebook Messenger 訊息 JSON 內容']
  created_by bigint [note: '建立者 ID']
  channel_id string(100) [note: '頻道 ID']
  interaction_tags json [note: '互動標籤（JSON 格式）']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '最後更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  indexes {
    send_status_index (send_status) [note: '優化發送狀態篩選查詢（草稿/已排程/已發送）']
    scheduled_time_index (scheduled_datetime_utc) [note: '優化排程任務觸發查詢']
    sent_time_index (send_time) [note: '優化歷史訊息時間排序查詢']
    campaign_index (campaign_id) [note: '優化活動訊息查詢']
    source_draft_id_index (source_draft_id) [note: '優化來源草稿查詢']
  }

  Note: '''
  訊息實體，用於群發訊息的管理與追蹤
  活動關聯：透過 campaign_id 可選關聯至 Campaign
    - 關聯活動：便於管理多波次訊息，支援活動層級統計
    - 獨立訊息：campaign_id 為 NULL，適用於日常通知、臨時公告

  篩選機制：v0 版使用 target_type + target_filter（標籤篩選）實現會員篩選，trigger_condition 為預留欄位不實作
  配額檢查：
    - 不變條件：若 available_quota < estimated_send_count，系統須阻擋發送行為；當 available_quota >= estimated_send_count 時允許發送（剛好相等視為足夠）
    - 檢查時機：使用者按下「送出/排程」即時呼叫後端驗證，未通過時立即返回錯誤訊息，阻止建立或排程
    - 排程執行前不再重複自動重試；配額不足時需由營運補額度或調整對象後再重新送出

  狀態轉換規則：
    - draft ⇄ scheduled：雙向轉換（允許取消排程）
    - scheduled → sending：系統開始執行發送作業，進入過渡狀態
    - sending → sent：成功發送後進入終止狀態，不可變更（防止重複發送）
    - sending → failed：發送過程中失敗（如：額度不足、API 錯誤）
    - failed → draft：允許修正問題後改回草稿，重新編輯並排程

  取消排程邏輯：
    - 操作方式：將 send_status 從 scheduled 改為 draft
    - 資料保留：保留所有訊息資料（message_content, scheduled_datetime_utc, target_filter, template_id 等）
    - 時間限制：無時間限制，任何時候都可取消
    - 後續操作：取消後可重新編輯訊息內容、調整排程時間並再次發送

  終止狀態：sent（不可逆）
  可重試狀態：failed（可改回 draft）

  效能優化索引：
    - send_status_index：訊息列表狀態篩選（高頻操作）
    - scheduled_time_index：排程任務系統觸發查詢（定時任務）
    - sent_time_index：歷史訊息時間排序
    - campaign_index：活動訊息聚合查詢

  關係：Message N:1 Campaign（可選）, Message 1:1 MessageTemplate, Message 1:N MessageDelivery
  '''
}

Table MessageDelivery {
  id bigint [pk, increment, note: '發送記錄唯一識別碼']
  message_id bigint [ref: > Message.id, note: '所屬訊息ID']
  member_id bigint [ref: > Member.id, note: '所屬會員ID']
  delivery_status string(20) [note: '發送狀態，上限 20 字元：pending（待發送）/ sent（已發送）/ failed（發送失敗）/ opened（已開啟）/ clicked（已點擊）']
  sent_at timestamp [note: '實際發送時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。允許 NULL（pending 狀態時為 NULL）']
  opened_at timestamp [note: '開啟時間（UTC）。會員首次開啟訊息的時間。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。允許 NULL（未開啟）']
  clicked_at timestamp [note: '點擊時間（UTC）。會員首次點擊訊息中按鈕或連結的時間。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。允許 NULL（未點擊）']
  failure_reason string(500) [note: '發送失敗原因，上限 500 字元。當 delivery_status = failed 時記錄失敗原因（如：LINE API 錯誤、會員封鎖等）。允許 NULL']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  indexes {
    message_member (message_id, member_id) [note: '優化訊息-會員組合查詢']
    member_status (member_id, delivery_status) [note: '優化會員發送狀態查詢']
    sent_time_index (sent_at) [note: '優化發送時間排序查詢']
  }

  Note: '''
  訊息發送明細實體，追蹤每個會員的群發訊息發送狀態

  業務價值：
    - 追蹤個別會員的發送成功/失敗狀態，支援失敗重試
    - 精準統計開啟率、點擊率（以會員為單位）
    - 分析會員互動行為（已發送但未開啟、已開啟但未點擊等）
    - 支援「需回覆會員」功能（追蹤已讀但未互動的會員）

  狀態轉換：
    - 線性流程：pending → sent → opened → clicked，不能跳過或回退
    - pending → failed：發送失敗（可重試，但需人工觸發回到 pending 後重新排程 sent → opened → clicked 流程）
    - sent：若會員未開啟，可能停留於 sent 終止
    - clicked：最終狀態，不再變動
    - 多渠道追蹤口徑：clicked 以追蹤連結統一記錄（所有渠道適用）；opened 僅對支援讀取回報的渠道（LINE）寫入，Facebook/Instagram 等無已讀回報的渠道 opened 永遠為 NULL（直接跳過 opened 狀態，維持 sent → clicked）

  資料量管理：
    - 預估資料量：會員數 × 訊息數（如 10,000 會員 × 100 訊息 = 1,000,000 筆）
    - 主表僅保留最近 90 天資料（依 created_at 判斷）
    - 歷史資料搬移：每日 02:00 排程以批次方式（建議 5,000 筆/批）執行 INSERT … SELECT 搬移 created_at < current_date - 90 天的資料至 MessageDeliveryArchive，成功後再刪除主表資料，並記錄搬移筆數、耗時與錯誤日誌

  查詢優化：
    - (message_id, member_id)：查詢特定訊息對特定會員的發送狀態
    - (member_id, delivery_status)：查詢特定會員的所有待處理/失敗訊息
    - sent_at：依發送時間排序和統計

  關係：MessageDelivery N:1 Message, MessageDelivery N:1 Member
  '''
}

Table MessageDeliveryArchive [note: 'DEPRECATED - 未實作'] {
  id bigint [pk, increment, note: '歸檔後的發送記錄唯一識別碼']
  message_id bigint [note: '所屬訊息ID']
  member_id bigint [note: '所屬會員ID']
  delivery_status string(20) [note: '發送狀態：pending / sent / failed / opened / clicked']
  sent_at timestamp [note: '實際發送時間（UTC）']
  opened_at timestamp [note: '開啟時間（UTC）']
  clicked_at timestamp [note: '點擊時間（UTC）']
  failure_reason string(500) [note: '發送失敗原因，上限 500 字元']
  created_at timestamp [note: '建立時間（UTC）']
  archived_at timestamp [note: '歸檔時間（UTC），記錄資料被移出主表的時間']

  indexes {
    archive_member_status (member_id, delivery_status)
    archive_sent_time (sent_at)
  }

  Note: '''
  MessageDelivery 歷史資料表，保存 90 天以上的發送記錄

  設計目的：降低主表資料量並保留歷史查詢能力
  資料來源：每日 02:00 排程自動將主表超過 90 天的資料搬移至本表
  查詢範圍：僅用於後台匯出或歷史資料查詢（唯讀），不得回寫主表
  '''
}

Table MessageTemplate {
  id bigint [pk, increment, note: '模板唯一識別碼']
  name string(100) [note: '模板名稱（選填，用於模板庫顯示），上限 100 字元。建議格式：「春節促銷」、「新會員歡迎」等描述性名稱']
  is_in_library bool [note: '是否加入模板庫：true 加入模板庫（可在模板庫選擇）/ false 不加入（僅限該群發使用）。預設值：false']
  source_template_id bigint [note: '複製來源模板ID（選填）。若此模板是從模板庫選擇並複製而來，記錄原始模板ID，用於追蹤來源。允許 NULL（從空白建立的模板）']
  text_content text [note: '文字內容（選填），使用 TEXT 型別不限長度']
  image_url string(500) [note: '圖片 URL（選填），上限 500 字元。圖片格式限制：僅支援 JPG/JPEG 格式（副檔名 .jpg 或 .jpeg），驗證邏輯：前端上傳時檢查檔案 MIME type 為 image/jpeg，後端 API 驗證檔案副檔名與 Content-Type。圖片尺寸要求：最小 800x800 像素（確保 LINE 訊息清晰度），前端驗證圖片尺寸，後端 API 二次驗證，拒絕小於此尺寸的圖片。圖片處理流程：(1) 前端上傳原圖（檔案大小 <= 1 MB）、(2) 前端顯示裁切預覽工具，使用者可拖曳調整裁切位置、(3) 裁切為正方形（1:1 比例）、(4) 儲存裁切後圖片 URL']
  title string(100) [note: '標題（選填），上限 100 字元']
  description text [note: '內文描述（選填），使用 TEXT 型別不限長度']
  amount int [note: '金額數值（選填），整數型別，不允許小數，>= 0']
  button_text string(50) [note: '按鈕文字（選填），上限 50 字元']
  button_count int [note: '顯示的文字按鈕數量，範圍：0-4（LINE Messaging API 限制單一訊息最多 4 個按鈕）。驗證層級：前端 UI 層限制 + 後端 API 驗證。資料庫層建議使用 CHECK 約束：CHECK (button_count >= 0 AND button_count <= 4)']
  interaction_tag string(200) [note: '互動標籤（選填，用於數據追蹤），上限 200 字元，支援多個標籤以逗號分隔，如「雙十,檔期優惠」']
  tag_trigger_mode string(20) [note: '標籤觸發模式（當設定多個互動標籤時），上限 20 字元：all（全部觸發）/ primary（僅主標籤）。all：所有標籤都記錄並累加 trigger_count；primary：只記錄第一個標籤，其他標籤作為描述用途']
  action_url string(500) [note: '按鈕開啟的 URL 網址（選填），上限 500 字元。若訊息模板包含按鈕，則此欄位為必填。草稿容錯：儲存草稿時允許為 NULL；發送前驗證：發送訊息時若有按鈕但 URL 未填寫則阻擋發送']
  notification_message string(500) [note: '通知訊息（必填），上限 500 字元。內容將隨 LINE 推播作為手機通知橫幅，前端必須提供']
  preview_message string(500) [note: '訊息預覽（必填），上限 500 字元。內容作為 LINE 聊天列表顯示的摘要，前端必須提供']
  carousel_count int [note: '輪播圖卡數量（選填，有效範圍 2-9 張，單張圖片不算輪播），>= 2']
  flex_message_json text [note: 'LINE Flex Message JSON（後端根據上述欄位自動生成），使用 TEXT 型別。若大小 < 10KB 則儲存於此欄位；若 >= 10KB 則上傳至 CDN 並將此欄位設為 NULL，URL 儲存於 flex_message_url。用於實際發送到 LINE API。格式：標準的 LINE Flex Message JSON 結構']
  flex_message_url string(500) [note: 'Flex Message CDN URL（選填），上限 500 字元。當 flex_message_json 大小 >= 10KB 時，上傳至 CDN 並儲存 URL 於此欄位。發送時優先使用此欄位，若為 NULL 則使用 flex_message_json']
  flex_message_size int [note: 'Flex Message JSON 大小（單位：bytes），用於判斷儲存策略。>= 0']
  storage_type string(20) [note: 'Flex Message 儲存類型，上限 20 字元：database（JSON 儲存於 flex_message_json）/ cdn（JSON 儲存於 CDN，URL 在 flex_message_url）/ database_fallback（原應上傳 CDN 但因錯誤暫存於資料庫，待後續補上傳）。預設值：database']
  needs_cdn_retry bool [note: '是否待重新上傳 CDN。流程：大於 10KB 的 JSON 需上傳 CDN，若連續 3 次重試仍失敗則將 JSON 暫存於 flex_message_json、storage_type = database_fallback，並將 needs_cdn_retry 設為 true 供排程重新上傳']
  upload_error_message string(500) [note: '最後一次 CDN 上傳錯誤訊息，上限 500 字元。僅於 storage_type = database_fallback 時記錄，供後台顯示與調查']
  usage_count int [note: '使用次數統計（模板被選擇複製的次數），>= 0。用途：模板庫排序（熱門優先）']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  訊息模板實體，用於儲存配置區填寫的欄位資料

  模板來源：(1) 從模板庫選擇既有模板（複製建立新記錄）、(2) 從空白建立新模板
  模板庫管理：is_in_library = true 的模板會顯示在模板庫，供其他群發選擇複製
  複製機制：從模板庫選擇模板時，系統複製所有欄位資料建立新 MessageTemplate 記錄，並記錄 source_template_id 追蹤來源
  獨立編輯：每個 Message 都有自己專屬的 MessageTemplate（1:1 關係），編輯不影響其他群發或原始模板
  加入模板庫：建立群發時可選擇是否將模板加入模板庫（設定 is_in_library = true），供未來重用
  使用統計：usage_count 記錄模板被選擇複製的次數，用於模板庫排序（熱門優先）

  Flex Message 生成與儲存：
    - 用戶在配置區填寫欄位（text_content, image_url, title 等），系統即時預覽並由後端自動生成 LINE Flex Message JSON
    - 不區分固定的模板類型，由填寫的欄位組合決定最終的 Flex Message 結構
    - flex_message_json 欄位由後端根據填寫的欄位自動生成，前端不需處理 JSON 編輯
  LINE 通知文字：
    - notification_message 與 preview_message 皆為必填，直接傳給 LINE Messaging API 使用
    - 系統僅負責儲存並於發送時帶入 API，不額外加工文字

  混合儲存策略（解決大型 JSON 導致的效能問題 #b3da7ae）：
    - 小型模板（< 10KB）：儲存於 flex_message_json 欄位，storage_type = 'database'
    - 大型模板（>= 10KB）：上傳至 CDN，URL 儲存於 flex_message_url，flex_message_json = NULL，storage_type = 'cdn'
    - CDN 上傳失敗時：啟動指數退避重試 3 次（1s/2s/4s），全部失敗則降級為 storage_type = 'database_fallback'，保留 JSON 於 flex_message_json、needs_cdn_retry = true、upload_error_message 記錄最後錯誤，供排程或後台重新上傳
    - 發送邏輯：優先使用 flex_message_url（若不為 NULL），否則使用 flex_message_json（含 database_fallback 情境）
    - 大小判斷：透過 flex_message_size 欄位記錄 JSON 大小（單位：bytes），用於儲存策略判斷與重試條件

  輪播規則：必須至少 2 張圖片才算輪播，單張圖片不使用輪播功能
  多標籤觸發規則：由 tag_trigger_mode 決定，all 時所有標籤都記錄，primary 時只記錄第一個標籤
  '''
}

Table TemplateCarouselItem {
  id bigint [pk, increment, note: '輪播圖卡唯一識別碼']
  template_id bigint [ref: > MessageTemplate.id, note: '所屬訊息模板ID']
  sequence_order int [note: '圖卡順序編號（1-9），用於控制輪播顯示順序。範圍：1-9，對應 MessageTemplate.carousel_count。刪除圖卡後自動遞補序號，保持連續。資料庫層建議使用 CHECK 約束：CHECK (sequence_order >= 1 AND sequence_order <= 9)']
  image_url string(500) [note: '圖片 URL，上限 500 字元。圖片格式限制：僅支援 JPG/JPEG 格式（副檔名 .jpg 或 .jpeg），驗證邏輯：前端上傳時檢查檔案 MIME type 為 image/jpeg，後端 API 驗證檔案副檔名與 Content-Type。圖片尺寸要求：最小 800x800 像素（確保 LINE 訊息清晰度），前端驗證圖片尺寸，後端 API 二次驗證，拒絕小於此尺寸的圖片。圖片處理流程：(1) 前端上傳原圖（檔案大小 <= 1 MB）、(2) 前端顯示裁切預覽工具，使用者可拖曳調整裁切位置、(3) 裁切為正方形（1:1 比例）、(4) 儲存裁切後圖片 URL']
  title string(100) [note: '圖卡標題（選填），上限 100 字元']
  description text [note: '圖卡內文描述（選填），使用 TEXT 型別不限長度']
  button_text string(50) [note: '按鈕文字（選填），上限 50 字元']
  action_url string(500) [note: '按鈕開啟的 URL 網址（選填），上限 500 字元。若圖卡包含按鈕，則此欄位為必填。草稿容錯：儲存草稿時允許為 NULL；發送前驗證：發送訊息時若有按鈕但 URL 未填寫則阻擋發送']
  interaction_tag string(200) [note: '互動標籤（選填，用於數據追蹤），上限 200 字元，支援多個標籤以逗號分隔，如「雙十,檔期優惠」']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  indexes {
    template_sequence (template_id, sequence_order) [unique, note: '確保同一模板內序號唯一，優化輪播圖卡查詢']
  }

  Note: '''
  輪播圖卡實體，用於儲存輪播訊息中每張圖卡的獨立配置

  設計原則：
    - 每張圖卡獨立設定：支援不同的標題、內文、按鈕、連結、互動標籤
    - 關聯方式：透過 template_id 關聯至 MessageTemplate，透過 sequence_order 控制順序
    - 序號管理：刪除圖卡後自動調整剩餘圖卡序號，保持 1-N 連續

  業務規則：
    - 輪播圖卡數量：2-9 張（MessageTemplate.carousel_count 記錄總數）
    - 序號範圍：1 到 carousel_count，必須連續無間斷
    - 唯一性約束：(template_id, sequence_order) 組合唯一

  互動追蹤：
    - ComponentInteractionLog.carousel_item_id 關聯至此表的 carousel_item_id
    - 支援追蹤每張圖卡的獨立點擊行為

  刪除與序號遞補規則：
    - 刪除圖卡時，系統自動調整剩餘圖卡的 sequence_order
    - 範例：刪除序號 3 的圖卡後，原序號 4、5 自動調整為 3、4
    - 同步更新 MessageTemplate.carousel_count（減 1）

  關係：TemplateCarouselItem N:1 MessageTemplate, TemplateCarouselItem 1:N ComponentInteractionLog
  '''
}

// ============================================
// TemplateButton 表已移除
// ============================================
// 實作決策（2025-11-20）：不使用獨立的 TemplateButton 資料表
// 原因：按鈕數量少（最多4個）且結構簡單，使用 JSON 儲存更高效
// 實作方式：按鈕資料儲存在 MessageTemplate.buttons JSON 欄位
// 詳見：implementation_decisions.md
// ============================================

Table MessageRecord [note: 'DEPRECATED - 已被 ConversationMessage 取代，migration 97c1b3771116 刪除'] {
  id bigint [pk, increment, note: '訊息紀錄唯一識別碼']
  member_id bigint [ref: > Member.id, note: '所屬會員']
  message_content string [note: '訊息內容']
  message_type string [note: '訊息類型：純文字 / 圖片 / 訊息模板']
  message_status string [note: '訊息狀態：已讀 / 未讀（未讀不標記）']
  send_time timestamp [note: '傳送時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。前端顯示時使用 12 小時制並分為 5 個時段：上午/中午/下午/晚上/凌晨（台灣時區 UTC+8）']
  message_source string [note: '訊息來源：會員主動（會員發送給飯店） / 人工回覆（顯示帳號名稱） / 訊息推播 / 自動回應。會員主動訊息透過 LINE Webhook 接收並儲存，用於聊天記錄查詢與「需回覆會員」功能（24 小時內主動互動）']
  conversation_date date [note: '對話開啟日期，格式：yyyy-mm-dd。前端顯示時包含星期（week）']
  scheduled_send bool [note: '是否排程發送']
  scheduled_date date [note: '排程指定日期，格式：yyyy-mm-dd']
  scheduled_time timestamp [note: '排程指定時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  indexes {
    member_conversation (member_id, conversation_date) [note: '優化會員對話歷史查詢，提升查詢速度 50%+']
    send_time_index (send_time) [note: '優化訊息時間排序查詢']
    scheduled_send_index (scheduled_send, scheduled_date) [note: '優化排程訊息查詢，< 100ms']
  }

  Note: '''
  訊息紀錄實體，用於一對一聊天記錄的管理（方案 B：混合儲存設計）

  儲存範圍：
    - 會員主動訊息：會員發送給飯店的訊息（文字、圖片、Sticker）
    - 系統回應訊息：人工回覆、訊息推播、自動回應

  訊息來源 (message_source) 值域：
    - 會員主動：會員透過 LINE 發送的訊息（message_type：純文字/圖片/Sticker）
    - 人工回覆：客服人員透過後台回覆（顯示帳號名稱）
    - 訊息推播：系統發送的群發訊息
    - 自動回應：觸發自動回應規則的訊息

  資料流向：
    - 會員主動訊息：LINE Webhook → 後端 API → MessageRecord 表 → 更新 Member.last_interaction_at
    - 系統發送訊息：後台操作 → MessageRecord 表 → LINE Messaging API 發送

  互動標籤關聯：
    - 會員點擊訊息按鈕觸發互動標籤時，記錄於 MemberTag 表
    - 透過 message_id 關聯 MessageRecord（或 Message 表，視訊息類型而定）

  應用場景：
    - 會員聊天記錄查詢：依 member_id + conversation_date 查詢對話歷史
    - 「需回覆會員」功能：篩選 24 小時內有主動訊息的會員（message_source = '會員主動' AND send_time > NOW() - 24h）
    - 客服回覆追蹤：查詢會員主動訊息後是否有人工回覆

  關係：MessageRecord N:1 Member
  '''
}

Table AutoResponse {
  id bigint [pk, increment, note: '自動回應唯一識別碼']
  trigger_type string [note: '觸發類型，採用可擴充設計，支援透過設定檔動態管理觸發類型清單。初始值域：新好友歡迎訊息（會員加入好友時觸發）、關鍵字觸發（會員訊息包含關鍵字時觸發）、指定時間觸發（特定時間/日期區間內觸發）。未來可透過管理後台或設定檔新增其他觸發類型（如：取消追蹤、加入群組、特定事件等），無需修改程式碼。必填欄位，不允許 NULL']
  trigger_time_start string [note: '指定時間區間起始（當 trigger_type = 指定時間觸發時使用）。格式：HH:mm（24小時制），如「18:00」。驗證規則：正則表達式 ^([01]\\d|2[0-3]):[0-5]\\d$，確保格式正確。允許 NULL（非指定時間觸發時為 NULL）']
  trigger_time_end string [note: '指定時間區間結束（當 trigger_type = 指定時間觸發時使用）。格式：HH:mm（24小時制），如「09:00」。驗證規則：正則表達式 ^([01]\\d|2[0-3]):[0-5]\\d$，確保格式正確。跨日判斷：當 time_range_end < time_range_start 時表示跨日（如 18:00-09:00 表示晚上 18:00 到隔天早上 09:00）。允許 NULL（非指定時間觸發時為 NULL）']
  date_range_start string(20) [note: '指定日期區間起始（當 trigger_type = 指定時間觸發時使用）。格式：yyyy/mm/dd，如「2025/02/01」。允許 NULL（不限定日期範圍時為 NULL）']
  date_range_end string(20) [note: '指定日期區間結束（當 trigger_type = 指定時間觸發時使用）。格式：yyyy/mm/dd，如「2025/02/28」。允許 NULL（不限定日期範圍時為 NULL）']
  weekdays string(20) [note: '週期性規則（選填），上限 20 字元。格式：逗號分隔的數字，1=週一, 2=週二, ..., 7=週日。範例：「1,2,3,4,5」表示週一至週五，「6,7」表示週末。允許 NULL（不限定星期）。用途：實現「每週一至週五 18:00-09:00」等週期性自動回應']
  scheduled_mode string(20) [note: '指定時間觸發模式（當 trigger_type = 指定時間觸發時使用），上限 20 字元。目前僅支援 passive（被動回應模式）：會員發訊息時判斷時間是否在範圍內，符合則回應。注意：自動回應不支援主動推播模式，僅支援被動觸發']
  is_active bool [note: '啟用狀態：true 啟用 / false 停用']
  response_count int [note: '設定的自動回應訊息數量（至少 1 筆，最多 5 筆），>= 1。驗證層級：應用層驗證，UI 層限制輸入範圍 1-5。此欄位應與 AutoResponseMessage 記錄數量一致']
  channels json [note: '支持的渠道列表（JSON 格式），如 ["LINE", "Facebook"]。若為 NULL 表示全部渠道。用於多渠道自動回應篩選']
  name string(100) [note: '自動回應名稱']
  content text [not null, note: '回應內容']
  template_id bigint [note: '關聯訊息模板 ID']
  keywords json [note: '關鍵字列表（JSON 格式）']
  channel_id string(100) [note: '頻道 ID']
  version int [default: 1, note: '版本號']
  is_duplicate bool [default: false, note: '是否為複製']
  trigger_count int [default: 0, note: '觸發次數']
  success_rate decimal(5,2) [note: '成功率']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。前端顯示時轉換為台灣時區（UTC+8）']

  indexes {
    trigger_type_enabled (trigger_type, is_active, created_at) [note: '優化自動回應觸發查詢，支援優先順序排序']
  }

  Note: '''
  自動回應實體，用於設定訊息的自動回應規則
  觸發方式：新好友歡迎訊息、輸入關鍵字觸發、選擇指定時間觸發
  觸發類型擴充性：採用可擴充設計，未來可透過設定檔或管理後台動態新增觸發類型，支援 LINE webhook 新事件（如取消追蹤、加入群組等）
  訊息管理：自動回應的訊息內容透過 AutoResponseMessage 關聯表管理，最多 5 筆訊息
  訊息發送邏輯：觸發時依照 AutoResponseMessage 的 sequence_order 順序，依序發送所有訊息（1-5 筆）
  關鍵字管理：當 trigger_type = 關鍵字觸發時，關鍵字透過 AutoResponseKeyword 關聯表管理，最多 20 組關鍵字
  時間區間表示法：採用兩欄位設計（time_range_start, time_range_end），格式 HH:mm（24小時制）
  跨日判斷邏輯：當 time_range_end < time_range_start 時表示跨日情境（如 18:00-09:00 表示晚上 18:00 到隔天 09:00）
  時間區間比對：非跨日（09:00-18:00）→ current_time >= start AND current_time <= end；跨日（18:00-09:00）→ current_time >= start OR current_time <= end

  多觸發優先順序規則（方案 A：固定優先順序，僅執行第一個）：
    - 觸發機制說明：
      • 歡迎訊息（welcome_message）：會員加入好友時立即觸發，與其他觸發類型不衝突（獨立觸發）
      • 關鍵字觸發（keyword_trigger）vs 指定時間觸發（scheduled_trigger）：會員發送訊息時同時檢查
    - 優先順序定義（僅適用於會員發送訊息時）：
      1. 關鍵字觸發（keyword_trigger）- 最高優先（有命中關鍵字就回）
      2. 指定時間觸發（scheduled_trigger）- 次優先（關鍵字未命中時才檢查時間）
    - 排序邏輯：第一層按 trigger_type 排序（關鍵字 > 時間），第二層按 created_at ASC 排序（同類型時，最早建立的優先）
    - 執行策略：當多個自動回應同時觸發時，僅執行優先順序最高的 1 則
    - 範例場景：
      • 會員於「20:00」發送訊息「訂房」，同時觸發「關鍵字（訂房）」與「時間觸發（18:00-09:00）」→ 僅執行「關鍵字觸發」
      • 會員於「20:00」發送訊息「還有房間嗎」，未命中關鍵字但符合時間區間 →執行「時間觸發」
    - SQL 查詢範例（會員發送訊息時）：
      SELECT * FROM AutoResponse
      WHERE (keyword_matched OR time_matched) AND is_enabled = true
      ORDER BY
        CASE trigger_type
          WHEN 'keyword_trigger' THEN 1
          WHEN 'scheduled_trigger' THEN 2
        END,
        created_at ASC
      LIMIT 1

  不變條件：1 <= response_count <= 5（由應用層驗證）
  關係：AutoResponse 1:N AutoResponseMessage, AutoResponse 1:N AutoResponseKeyword
  '''
}

Table AutoResponseKeyword {
  id bigint [pk, increment, note: '關鍵字唯一識別碼']
  auto_response_id bigint [ref: > AutoResponse.id, note: '所屬自動回應']
  keyword string [note: '關鍵字文字，不區分大小寫，支援中英文與特殊字元，長度上限 50 字元。空字串驗證：不允許空字串或僅包含空白字元的關鍵字，前端與後端 API 皆驗證拒絕。自動處理：儲存前自動去除前後空白字元（trim），確保資料一致性']
  match_type string [note: '比對類型：包含匹配（預設）/ 完全匹配 / 正則表達式（未來擴充）。包含匹配：會員訊息包含此關鍵字即觸發；完全匹配：會員訊息完全等於此關鍵字才觸發']
  is_enabled bool [note: '是否啟用：true 啟用（參與比對）/ false 停用（不參與比對）。預設值：true']
  match_count int [note: '匹配次數，記錄該關鍵字被匹配的累計次數，>= 0。用途：統計分析哪些關鍵字最常被觸發']
  last_triggered_at timestamp [note: '最近觸發時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。用途：追蹤關鍵字活躍度']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  indexes {
    unique_response_keyword [unique, note: '確保 (auto_response_id, keyword) 組合唯一性，同一自動回應不可有重複關鍵字'] (auto_response_id, keyword)
  }

  Note: '''
  自動回應關鍵字關聯實體（一對多關係）
  用途：管理自動回應的關鍵字清單，支援個別關鍵字的觸發統計與狀態管理
  比對邏輯：預設為「包含匹配」且「不區分大小寫」，會員訊息包含任一啟用的關鍵字即觸發對應的自動回應
  數量限制：每個自動回應最多 20 組關鍵字（應用層驗證）
  唯一性約束：同一自動回應內的關鍵字文字不可重複（資料庫層約束）
  觸發統計：每次關鍵字觸發時更新 trigger_count 與 last_triggered_at，用於後台統計分析
  未來擴充：match_type 可支援正則表達式，提供更靈活的比對規則
  關係：AutoResponseKeyword N:1 AutoResponse
  '''
}

Table AutoResponseMessage {
  id bigint [pk, increment, note: '訊息唯一識別碼']
  auto_response_id bigint [ref: > AutoResponse.id, note: '所屬自動回應']
  message_content string [note: '訊息內容（純文字）。長度限制：建議 <= 500 字元（LINE 訊息建議長度）']
  sequence_order int [note: 'UI 顯示順序與發送順序，範圍 1-5。發送時依此順序由小到大依序發送。資料庫層建議 CHECK 約束：CHECK (sequence_order >= 1 AND sequence_order <= 5)，確保與自動回應訊息數量上限一致']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  indexes {
    unique_response_sequence [unique, note: '確保 (auto_response_id, sequence_order) 組合唯一性，同一自動回應不可有重複順序'] (auto_response_id, sequence_order)
  }

  Note: '''
  自動回應訊息關聯實體（一對多關係）
  用途：管理自動回應的訊息內容清單，支援 1-5 筆訊息的依序發送
  數量限制：每個自動回應最多 5 筆訊息（應用層驗證）
  發送邏輯：觸發時依照 sequence_order 順序由小到大依序發送所有訊息
  發送間隔：建議在訊息間加入短暫延遲（如 1-2 秒），模擬真人回覆節奏，避免洗版感
  順序管理：UI 支援拖曳排序，前端需維護 sequence_order 的連續性（1, 2, 3...）
  唯一性約束：同一自動回應內的 sequence_order 不可重複（資料庫層約束）
  使用場景：教學流程（步驟說明）、完整資訊傳遞（多段說明）、引導式對話（分段引導）
  關係：AutoResponseMessage N:1 AutoResponse
  '''
}


Table ConsumptionRecord {
  id bigint [pk, increment, note: '消費紀錄唯一識別碼']
  member_id bigint [ref: > Member.id, note: '所屬會員']
  consumption_time timestamp [note: '消費時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  amount float [note: '消費金額，>= 0，無特別上限限制（使用 float 型別範圍內）']
  room_type string [note: '房型或套餐']

  indexes {
    member_consumption (member_id, consumption_time) [note: '優化會員消費統計查詢（如：過去 12 個月消費金額），提升查詢速度 60%+']
    room_type_index (room_type) [note: '優化房型偏好分析查詢']
  }

  Note: '''
  消費紀錄實體，用於串接 CRM 系統的會員消費資料（v0.2）
  同步機制：
    - 同步頻率：每日凌晨 02:00 執行（飯店業務低峰期）
    - 同步模式：全量同步（CRM 資料為準，覆蓋本地資料）
    - 衝突處理：以 CRM 系統資料為唯一來源，不處理衝突
    - 失敗重試：記錄失敗日誌，次日自動重試；連續失敗超過 3 日則系統告警
    - 同步記錄：記錄同步時間、同步筆數、失敗原因供人工檢查
  用途：分析會員消費頻率、金額、房型偏好等行為資料，無需實時性
  關係：ConsumptionRecord N:1 Member
  '''
}

Table Campaign {
  id bigint [pk, increment, note: '活動唯一識別碼']
  campaign_name string(100) [note: '活動名稱，上限 100 字元']
  campaign_tag string(50) [note: '活動標籤，用於分類與篩選，上限 50 字元']
  campaign_date date [note: '活動日期，格式：yyyy-mm-dd。（保留欄位，建議改用 start_date / end_date）']
  start_date date [note: '活動開始日期，格式：yyyy-mm-dd。活動期間起始日']
  end_date date [note: '活動結束日期，格式：yyyy-mm-dd。活動期間結束日']
  description text [note: '活動描述，允許 NULL']
  status string(20) [note: '活動狀態：active（進行中）/ inactive（未啟用）/ completed（已完成）/ cancelled（已取消）。預設值：active。草稿僅存在於訊息模板（Message.send_status = draft）階段，不使用於此欄位']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '最後更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  行銷活動實體，作為多個群發訊息的容器
  業務場景：
    - 大型促銷活動（如：春節優惠、週年慶）需要發送多波次訊息
    - 活動前預告 → 活動期間提醒 → 活動結束感謝，統一歸類管理
    - 支援活動層級的數據統計與效果分析

  關係設計：Campaign 1:N Message（一個活動可包含多個群發訊息）
  使用方式：
    1. 建立 Campaign 定義活動基本資訊（名稱、標籤、日期、狀態）
    2. 建立多個 Message 並關聯至此 Campaign（透過 message.campaign_id）
    3. Campaign 作為訊息分組，方便管理與追蹤活動整體效果

  可選性：Message 可選擇是否關聯 Campaign
    - 關聯 Campaign：屬於特定活動的訊息，便於活動管理
    - 不關聯 Campaign：獨立訊息（如：日常通知、臨時公告）

  狀態管理：
    - active：正式活動進行中，允許新增或調整關聯 Message
    - completed：活動結束，系統於活動結束日或所有訊息完成發送後自動標記，或由營運手動結案
    - cancelled：活動取消，終止所有排程中的訊息，無法恢復

  狀態轉換規則：
    - active → completed：系統依活動結束條件自動更新，或營運手動結案
    - active → cancelled：營運可隨時緊急停止活動
    - completed、cancelled 皆為終止狀態，不可轉回 active

  草稿處理：
    - 草稿僅存在於 Message 模板（send_status = draft），可多次編輯或重複使用
    - 在草稿階段尚未進入 Campaign.status 流程，發送行為仍由 MessageDelivery 狀態控制

  關係：Campaign 1:N Message
  '''
}

Table PMS_Integration {
  id bigint [pk, increment, note: 'PMS 整合資料唯一識別碼']
  pms_type string [note: 'PMS 系統類型，採用可擴充設計。初始值域：dean_pms（德安）/ opera_pms（Oracle Opera）/ fidelio_pms（Fidelio）。未來可透過新增 Adapter 擴展其他 PMS 系統，無需修改資料庫結構。必填欄位，不允許 NULL']
  api_endpoint string [note: 'PMS API 端點完整 URL。格式：https://domain.com/api/v1。每家飯店可配置不同的 endpoint。必填欄位']
  api_key string [note: 'API 認證金鑰（加密儲存）。用於 API 請求認證，儲存前需使用加密演算法（如 AES-256）加密。必填欄位']
  config_json string [note: 'PMS 特定配置（JSON 格式）。包含：adapter_settings（adapter 特定設定）、field_mapping（欄位映射規則，如 {"id_number": "guestIdNo", "phone": "mobile"}）、auth_type（認證類型：bearer_token / api_key / oauth2）、sync_interval（同步頻率：realtime / hourly / daily）、retry_policy（重試策略）等。允許 NULL（使用預設配置）']
  id_number string [note: '身分證字號（用於關聯會員）。從 PMS 同步取得']
  phone string [note: '手機號碼（用於關聯會員）。從 PMS 同步取得']
  member_id bigint [ref: > Member.id, note: '關聯的會員ID。會員比對成功後建立關聯']
  sync_status string [note: '同步狀態，值域：active（正常同步）/ failed（同步失敗）/ disabled（已停用）。預設值：active']
  last_sync_at timestamp [note: '最後同步時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。記錄最近一次成功同步的時間']
  error_message string [note: '同步錯誤訊息。當 sync_status = failed 時記錄錯誤原因，用於除錯與監控。允許 NULL']
  consecutive_failed_count int [note: '連續同步失敗次數，預設 0。每次同步失敗自動 +1；成功同步後歸零']
  last_failed_at timestamp [note: '最近一次同步失敗時間（UTC）。配合 consecutive_failed_count 用於自動停用判斷']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  PMS 整合實體，支援多種 PMS 系統透過 Adapter Pattern 整合
  設計理念：採用 Adapter Pattern，每種 PMS 系統使用獨立的 adapter 處理資料同步與欄位映射
  初期支援：德安 PMS（dean_pms），實作 DeanPMSAdapter
  擴充策略：未來可新增 OperaPMSAdapter、FidelioPMSAdapter 等，新增 adapter 不需修改既有程式碼或資料庫結構
  API 配置：每家飯店可配置獨立的 api_endpoint 與 api_key，支援不同 PMS 版本與部署環境
  欄位映射：透過 config_json 的 field_mapping 定義 PMS 欄位與系統欄位的對應關係，不同 PMS 使用不同映射規則
  會員比對：以身分證字號/手機號碼作關聯，會員比對成功率 >= 95%
  定期更新機制：根據 sync_interval 設定執行定期同步，確保資料一致性
  同步狀態管理：
    - active：正常同步
    - failed：最近一次同步失敗，系統記錄 error_message、last_failed_at 並遞增 consecutive_failed_count
    - disabled：連續失敗達 3 次後系統自動停用（sync_status = disabled, is_active = false），須由管理員檢查並手動恢復
  失敗重試與停用：
    - 同步排程遇到失敗時觸發重試。若連續 3 次失敗則自動標記 disabled，停止後續自動同步
    - 管理員修正設定後可手動將 status 改回 active，同時將 consecutive_failed_count 歸零
    - 成功同步會自動將 sync_status 設回 active、清空 error_message、歸零 consecutive_failed_count
  警示處理：每次進入 failed 或 disabled 時產生系統通知，提示營運人員檢查
  比對失敗處理：無法比對至現有會員時，系統自動建立新會員並標記 join_source 為 PMS
  部分同步失敗處理策略：採用「跳過失敗」策略
    - 同步過程中遇到失敗筆數時，記錄錯誤詳情（包含失敗原因、失敗資料內容）到系統錯誤日誌
    - 跳過該筆失敗資料，繼續處理剩餘筆數，確保其他資料正常同步
    - 失敗筆數不自動重試，需透過管理後台或監控系統人工處理
    - 同步完成後提供摘要報告（成功 N 筆 / 失敗 M 筆），失敗筆數可匯出供人工檢視
    - 錯誤日誌保留 90 天供追蹤與審計
  錯誤處理：同步失敗時記錄 error_message 到 PMS_Integration 實體，單筆錯誤記錄到系統日誌
  安全性：api_key 加密儲存，config_json 不包含敏感資訊
  住宿紀錄儲存：採用正規化結構，住宿紀錄儲存於 StayRecord 明細表，支援標籤規則計算（如：過去 12 個月住宿次數 >= 3 次）與查詢效能優化
  關係：PMS_Integration N:1 Member, PMS_Integration 1:N StayRecord
  '''
}

Table StayRecord [note: 'DEPRECATED - 已被 PMS_Integration.stay_records JSON 欄位取代'] {
  id bigint [pk, increment, note: '住宿紀錄唯一識別碼']
  member_id bigint [ref: > Member.id, note: '所屬會員']
  pms_integration_id bigint [ref: > PMS_Integration.id, note: 'PMS 整合來源']
  check_in date [note: '入住日期，格式：yyyy-mm-dd']
  check_out date [note: '退房日期，格式：yyyy-mm-dd。日期關係驗證：check_out >= check_in（退房日期必須大於等於入住日期），允許同一天入住退房（如當日住宿情境）。驗證邏輯：前端與後端 API 皆實施驗證，拒絕 check_out < check_in 的資料']
  room_type string [note: '房型（如：雙人房、商務房、豪華套房）']
  booking_id string [note: 'PMS 訂單編號，用於追溯原始訂單']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  indexes {
    member_checkin (member_id, check_in) [note: '優化會員住宿頻率統計查詢（如：過去 12 個月住宿次數）']
    room_type_index (room_type) [note: '優化房型分類查詢（支援 TagRule 的 room_type 規則）']
  }

  Note: '''
  住宿紀錄明細實體，儲存會員在飯店的住宿歷史
  資料來源：從 PMS 系統同步取得，透過 PMS_Integration 關聯
  正規化設計：採用獨立明細表，支援高效查詢與標籤規則計算
  用途：
    1. 標籤規則計算：支援 TagRule 的 visit_frequency（訪問頻率）與 room_type（房型分類）規則
    2. 會員行為分析：統計住宿頻率、房型偏好、入住習慣
    3. 報表統計：提供住宿報表與趨勢分析
  索引優化：
    - (member_id, check_in)：優化滾動時間窗口查詢（如：過去 12 個月住宿次數）
    - (room_type)：優化房型分類查詢
  關係：StayRecord N:1 Member, StayRecord N:1 PMS_Integration
  '''
}

Table Admin {
  id bigint [pk, increment, note: '管理員唯一識別碼']
  email string [unique, note: '登入信箱，作為識別帳號']
  password_hash string [note: '密碼雜湊值（使用 bcrypt/Argon2 加密儲存）。密碼複雜度要求：長度 8-64 字元、至少包含 3 種類型（大寫字母、小寫字母、數字、特殊符號）、不允許連續字元或超過 3 次重複字元、不允許常見弱密碼、不允許與信箱相同。允許的特殊符號：!@#$%^&*()-_=+[]{}|;:,.<>?/~']
  name string [note: '管理員名稱']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  管理員實體，用於系統登入與權限管理
  登入方式：信箱+密碼 / Google 快速登入 / LINE 快速登入
  權限管理：採用 RBAC（Role-Based Access Control）系統，管理員透過角色獲得權限，支援動態權限配置
  狀態：legacy 過渡；計畫由 User 表取代（含帳號與權限資料遷移），保留期間僅為既有 RBAC/登入相容
  關係：Admin 1:1 LineOAConfig, Admin 1:1 LoginConfig, Admin 1:N LoginSession, Admin 1:N SystemAuthorization, Admin N:M Role (透過 AdminRole)
  '''
}

Table Role {
  id bigint [pk, increment, note: '角色唯一識別碼']
  role_name string [unique, note: '角色名稱，如「超級管理員」「管理員」「一般員工」，不得重複']
  role_code string [unique, note: '角色代碼，如「superadmin」「admin」「staff」，用於程式識別，不得重複']
  description string [note: '角色描述，說明該角色的職責與適用範圍']
  is_system_role bool [note: '是否為系統預設角色（系統預設角色不可刪除，但可修改權限）']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '最後更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  角色實體，定義管理員的角色分類
  系統預設角色：superadmin（超級管理員，擁有所有權限）、admin（管理員，擁有大部分權限）、staff（一般員工，擁有基本權限）
  自訂角色：管理員可新增自訂角色並配置權限（如「行銷人員」「客服人員」等）
  角色刪除規則：
    1. 系統預設角色（is_system_role = true）：不可刪除，API 返回錯誤「系統預設角色不可刪除」
    2. 自訂角色（is_system_role = false）：允許刪除，刪除時級聯刪除 AdminRole 關聯記錄（管理員自動失去該角色權限）
    3. 刪除前提示：顯示「該角色已被 N 位管理員使用，刪除後這些管理員將失去該角色權限，是否繼續？」
    4. 級聯刪除：同時刪除 RolePermission 關聯記錄（角色權限配置清除）
  關係：Role N:M Admin (透過 AdminRole), Role N:M Permission (透過 RolePermission)
  '''
}

Table Permission {
  id bigint [pk, increment, note: '權限唯一識別碼']
  permission_name string [unique, note: '權限名稱，如「查看會員資料」「發送群發訊息」「管理標籤」，不得重複']
  permission_code string [unique, note: '權限代碼，如「member.view」「message.send」「tag.manage」，用於程式判斷，不得重複']
  resource string [note: '資源類別，如「member」「message」「tag」「campaign」「admin」等']
  action string [note: '操作類型，如「view」「create」「update」「delete」「manage」等']
  description string [note: '權限描述，說明該權限的作用範圍']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  權限實體，定義系統功能的存取控制
  權限命名規則：permission_code 採用「資源.操作」格式（如 member.view, message.send）
  權限分類（resource）：member（會員管理）、message（訊息管理）、tag（標籤管理）、campaign（行銷活動）、admin（管理員管理）、system（系統設定）、pms（PMS 整合）、autoresponse（自動回應）等
  操作分類（action）：view（查看）、create（建立）、update（編輯）、delete（刪除）、manage（完整管理，包含 CRUD）、export（匯出）、import（匯入）、send（發送）、config（設定）、sync（同步）、analytics（數據分析）等

  權限初始化策略：混合模式
    1. 核心權限（透過資料庫 migration 初始化）：系統部署時自動建立，確保跨環境一致性
       - member.*（6 個）：view, create, update, delete, export, import
       - tag.*（6 個）：view, create, update, delete, assign, rule.manage
       - message.*（6 個）：view, send, schedule, template, reply, analytics
       - autoresponse.*（4 個）：view, create, update, delete
       - campaign.*（5 個）：view, create, update, delete, analytics
       - pms.*（4 個）：view, config, sync, consumption
       - admin.*（5 個）：view, create, update, delete, role.manage
       - system.*（3 個）：config, auth, log
       共計 39 個核心權限

    2. 擴展權限（透過管理後台動態新增）：支援未來平台擴展，無需 migration
       - 未來可新增：meta.*（Meta/FB/IG 平台）、whatsapp.*（WhatsApp）、automation.*（自動化場景）、event.*（事件日誌）等
       - 管理員可透過後台「權限管理」功能新增自訂權限

  關係：Permission N:M Role (透過 RolePermission)
  '''
}

Table AdminRole {
  id bigint [pk, increment, note: '關聯唯一識別碼']
  admin_id bigint [ref: > Admin.id, note: '管理員 ID']
  role_id bigint [ref: > Role.id, note: '角色 ID']
  assigned_at timestamp [note: '指派時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  assigned_by string [note: '指派人（管理員 ID），記錄由誰指派此角色']

  indexes {
    unique_admin_role [unique, note: '確保 (admin_id, role_id) 組合唯一性，同一管理員不可重複指派相同角色'] (admin_id, role_id)
  }

  Note: '''
  管理員-角色關聯實體（多對多關係）
  用途：管理員可擁有多個角色，角色可被多個管理員擁有
  權限計算：管理員的最終權限 = 所有角色的權限聯集（union）
  指派規則：僅擁有「admin.manage」權限的管理員可指派角色
  角色數量限制：單一管理員可指派的角色數量無上限（彈性支援複雜權限組合需求）
  級聯刪除規則：
    - 當 Role 被刪除時，級聯刪除所有關聯的 AdminRole 記錄（ON DELETE CASCADE）
    - 當 Admin 被刪除時，級聯刪除所有關聯的 AdminRole 記錄（ON DELETE CASCADE）
  關係：AdminRole N:1 Admin, AdminRole N:1 Role
  '''
}

Table RolePermission {
  id bigint [pk, increment, note: '關聯唯一識別碼']
  role_id bigint [ref: > Role.id, note: '角色 ID']
  permission_id bigint [ref: > Permission.id, note: '權限 ID']
  granted_at timestamp [note: '授予時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  granted_by string [note: '授予人（管理員 ID），記錄由誰授予此權限']

  indexes {
    unique_role_permission [unique, note: '確保 (role_id, permission_id) 組合唯一性，同一角色不可重複授予相同權限'] (role_id, permission_id)
  }

  Note: '''
  角色-權限關聯實體（多對多關係）
  用途：角色可擁有多個權限，權限可被多個角色擁有
  動態配置：管理員可動態新增/移除角色的權限，即時生效
  授權規則：僅擁有「admin.manage」權限的管理員可配置角色權限
  關係：RolePermission N:1 Role, RolePermission N:1 Permission
  '''
}

Table LineOAConfig [note: 'DEPRECATED - 功能已由 LineChannel 表取代'] {
  id bigint [pk, increment, note: '設定唯一識別碼']
  admin_id bigint [ref: > Admin.id, note: '所屬管理員']
  channel_id string [note: 'Messaging API Channel ID。格式要求：10 位數字。範例：1234567890。驗證：前端即時驗證格式，後端最終驗證']
  channel_secret string [note: 'Messaging API Channel Secret。格式要求：32 字元英數字。範例：abcdef1234567890abcdef1234567890。驗證：前端即時驗證格式，後端最終驗證。用途：計算 Webhook 簽章（HMAC-SHA256）']
  channel_access_token string [note: 'Messaging API Channel Access Token。格式要求：最少 50 字元。驗證：前端檢查最小長度，後端調用 LINE Get Bot Info API (GET https://api.line.me/v2/bot/info) 驗證有效性']
  line_account_id string [note: 'LINE 官方帳號 ID，如 @262qaash']
  webhook_enabled bool [note: 'Webhook 是否已開啟']
  is_verified bool [note: '是否已完成 LINE 驗證']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '最後更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  LINE 官方帳號設定實體
  驗證條件：channel_id, channel_secret, channel_access_token 三項必填且格式正確
  驗證規則：須向 LINE 原生後台驗證成功，且 webhook 已開啟
  關係：LineOAConfig N:1 Admin
  '''
}

Table LoginConfig [note: 'DEPRECATED - 功能已由 LineChannel 表取代'] {
  id bigint [pk, increment, note: '設定唯一識別碼']
  admin_id bigint [ref: > Admin.id, note: '所屬管理員']
  channel_id string [note: 'Login Channel ID，格式：以 165 開頭的 10 位數字（LINE Login 官方格式）']
  channel_secret string [note: 'Login Channel Secret，32 位大小寫英數字（LINE Login 官方格式）']
  is_verified bool [note: '是否已完成 LINE 驗證']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  updated_at timestamp [note: '最後更新時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  LINE Login Channel 設定實體（管理員設定，供會員使用）
  驗證條件：channel_id, channel_secret 兩項必填且格式正確
  用途：管理員設定 LINE Login Channel 後，會員可透過 LINE Login 授權登入，系統藉此整併會員資料（如姓名、email、頭像等）
  關係：LoginConfig N:1 Admin（一個管理員可設定一組 LINE Login Channel）
  '''
}

Table LoginSession [note: 'DEPRECATED - 未實作，使用 JWT Token'] {
  id bigint [pk, increment, note: '會話唯一識別碼。生成規則：使用 UUID v4（標準隨機 UUID，128 位元），格式為 8-4-4-4-12 的 36 字元字串（如：550e8400-e29b-41d4-a716-446655440000）。UUID v4 提供全球唯一性保證、無碰撞風險、不可預測性，確保會話安全性。前後端 API 使用標準 UUID 字串格式傳輸']
  admin_id bigint [ref: > Admin.id, note: '所屬管理員']
  login_method string [note: '登入方式：email_password / google / line']
  login_time timestamp [note: '登入時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串。前端顯示時轉換為台灣時區（UTC+8）']
  expire_time timestamp [note: '會話過期時間（UTC）。取「登入時間 + 24 小時」與「下一個 00:00（UTC+8）」兩者較早者。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']
  device_info string [note: '裝置資訊']
  is_active bool [note: '會話是否有效']

  indexes {
    active_session (admin_id, is_active) [note: '優化活躍會話查詢，支援會話驗證 < 50ms']
    expire_time_index (expire_time) [note: '優化會話過期清理任務，提升清理效能 60%+']
  }

  Note: '''
  管理員登入會話實體（記錄管理員登入狀態）
  會話管理：同一管理員帳號可在不同裝置同時登入，各自維護獨立會話
  自動登出：會話於 UTC+8 時區下，取登入時間 + 24 小時與下一個 00:00 的較早者自動失效
  過期策略：
    - 系統僅在 API 驗證時檢查 expire_time 與 is_active，過期後將 is_active 標記為 false
    - 不實作「記住我」或閒置逾時延長機制，所有會話都遵守同一到期規則
    - 過期或手動登出僅更新狀態，不刪除 LoginSession 紀錄（保留登入稽核歷史）
  閒置控制：不追蹤 last_activity，亦不因閒置自動登出；安全性由 24 小時 / 跨日失效機制保障
  資料保留：不執行排程清理過期會話，保留完整登入紀錄以供稽核
  登入方式：支援 email_password、google、line 三種方式
  關係：LoginSession N:1 Admin（一個管理員可有多筆會話記錄）
  '''
}

Table SystemAuthorization [note: 'DEPRECATED - 未實作'] {
  id bigint [pk, increment, note: '授權唯一識別碼']
  admin_id bigint [ref: > Admin.id, note: '所屬管理員']
  expire_date date [note: '授權到期日，格式：yyyy-mm-dd']
  is_active bool [note: '授權是否有效']
  created_at timestamp [note: '建立時間（UTC）。資料庫儲存 UTC 時間，API 回傳時轉換為 ISO 8601 格式字串']

  Note: '''
  系統授權實體
  授權控制：未付款或授權過期則無法使用系統功能，並即時將所有登入會話失效
  到期提醒：授權到期前 7 日內，每次登入彈窗提示（v0.3）
  過期後的系統行為：採用「立即中止所有操作」策略
    1. 登入會話：所有管理員的 LoginSession 立即失效（is_active = false），強制登出
    2. 排程任務：排程中的群發訊息（Campaign）立即停止觸發，已排程但未發送的訊息不執行
    3. PMS 同步任務：停止所有 PMS 同步操作，不再執行定期同步與資料拉取
    4. 自動回應：停止處理會員訊息的自動回應觸發，收到的訊息不回覆
    5. 背景任務：所有背景執行的任務（如標籤統計、資料清理等）立即停止
    6. 檢查機制：每個需要授權的操作執行前，檢查 SystemAuthorization.is_active 與 expire_date，過期則拒絕執行並返回錯誤「系統授權已過期，請聯繫管理員」
    7. 續約恢復：續約後 is_active 恢復為 true，所有功能立即恢復正常（管理員需重新登入）
  關係：SystemAuthorization N:1 Admin
  '''
}

// ============================================
// 多渠道整合相關資料表（v0.4.0 新增）
// ============================================
// 支援 LINE / Facebook / Webchat 三渠道整合
// 詳見：spec/features/聊天室多渠道
// ============================================

Table LineChannel {
  id bigint [pk, increment, note: 'LINE 頻道唯一識別碼']
  channel_id string(100) [unique, note: 'LINE Channel ID']
  channel_access_token string(500) [not null, note: '頻道存取權杖']
  channel_secret string(100) [not null, note: '頻道密鑰']
  channel_name string(100) [note: '頻道名稱']
  basic_id string(100) [note: 'LINE Bot Basic ID（格式：@xxxxxxx）']
  liff_id_open string(100) [note: 'LIFF ID']
  login_channel_id string(100) [note: 'LINE Login Channel ID']
  login_channel_secret string(100) [note: 'LINE Login Channel Secret']
  is_active bool [not null, default: true, note: '是否啟用']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  Note: '''
  LINE 頻道設定實體，支援多頻道管理
  用途：儲存 LINE Messaging API 頻道設定，支援多個 LINE 官方帳號管理
  與 LineOAConfig 的區別：LineChannel 用於多頻道設定，LineOAConfig 用於單一管理員綁定
  '''
}

Table FbChannel {
  id bigint [pk, increment, note: 'Facebook 頻道唯一識別碼']
  page_id string(255) [unique, note: 'Facebook Page ID']
  page_access_token string(500) [not null, note: 'FB 頻道存取權杖']
  app_id string(255) [note: 'Facebook App ID']
  app_secret string(255) [note: 'Facebook App Secret']
  channel_name string(100) [note: '頻道名稱']
  is_active bool [not null, default: true, note: '是否啟用']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  Note: '''
  Facebook 頻道設定實體
  用途：儲存 Facebook Messenger API 頻道設定，支援 Facebook 客服聊天功能
  關係：FbChannel 與 ChatLog 關聯（透過 platform = 'Facebook'）
  '''
}

Table ConversationThread {
  id bigint [pk, increment, note: '對話串唯一識別碼']
  member_id bigint [ref: > Member.id, note: '關聯會員 ID（選填）。已關聯會員後填入，用於跨渠道整合查詢']
  platform string(20) [not null, note: '渠道類型：LINE / Facebook / Webchat']
  platform_uid string(100) [not null, note: '渠道原始 UID（LINE UID / FB UID / Webchat UID）']
  conversation_name string(200) [note: '對話名稱，格式：{platform}:{display_name}']
  last_message_at timestamp [note: '最後訊息時間（UTC），用於排序和找出最近互動渠道']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  indexes {
    member_platform_index (member_id, platform) [note: '優化會員多渠道查詢，支援渠道切換']
    platform_uid_index (platform, platform_uid) [note: '優化渠道 UID 查詢']
    last_message_index (member_id, last_message_at) [note: '優化最近互動渠道查詢']
  }

  Note: '''
  對話串實體，用於整合多渠道聊天記錄（方案 A：單表 + platform 欄位）

  核心功能：
    1. 作為聊天訊息的容器，每個渠道用戶一個對話串
    2. 透過 member_id 關聯會員，支援跨渠道整合顯示
    3. 透過 platform 欄位區分不同渠道

  ID 格式規範：
    - LINE:U1234567890abcdef → LINE 用戶
    - FB:F9876543210fedcba → Facebook 用戶
    - WEB:W5555555555555555 → Webchat 訪客

  與 Members 表的關係：
    - 未登入訪客：member_id = NULL，僅有 platform_uid
    - 已登入會員：member_id 填入，可跨渠道整合查詢
    - 會員合併時：多個 ConversationThread 共用同一 member_id

  客服聊天室查詢邏輯：
    - 整合顯示：SELECT * FROM conversation_messages WHERE thread_id IN (SELECT id FROM conversation_threads WHERE member_id = ?) ORDER BY created_at
    - 渠道篩選：加上 AND platform = ?
    - 預設渠道：SELECT platform FROM conversation_threads WHERE member_id = ? ORDER BY last_message_at DESC LIMIT 1

  關係：ConversationThread 1:N ConversationMessage, ConversationThread N:1 Member
  '''
}

Table ConversationMessage {
  id bigint [pk, increment, note: '訊息唯一識別碼']
  thread_id bigint [ref: > ConversationThread.id, not null, note: '所屬對話串 ID']
  platform string(20) [not null, note: '渠道類型：LINE / Facebook / Webchat（冗餘欄位，方便查詢時避免 JOIN）']
  role string(20) [note: '角色：user（會員訊息）/ assistant（系統回應，包括客服、GPT、自動回應）']
  direction string(20) [not null, note: '方向：incoming（收到）/ outgoing（發出）']
  message_type string(50) [note: '訊息類型：text / image / sticker / postback / flex 等']
  question text [note: '用戶訊息內容（direction=incoming 時使用）']
  response text [note: '系統回應內容（direction=outgoing 時使用）']
  message_source string(20) [note: '訊息來源：webhook（用戶訊息）/ manual（人工回覆）/ gpt（GPT 自動回應）/ keyword（關鍵字觸發）/ welcome（歡迎訊息）/ always（全時自動回應）/ broadcast（訊息推播）']
  event_id string(100) [note: '事件 ID（LINE eventId 等，用於去重）']
  status string(20) [note: '狀態：received / sent / read / failed']
  created_at timestamp [default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  indexes {
    thread_id_index (thread_id) [note: '優化對話串訊息查詢']
    platform_index (platform) [note: '優化渠道篩選查詢']
    created_at_index (created_at) [note: '優化時間排序查詢']
    thread_created_index (thread_id, created_at) [note: '優化對話串時間排序查詢']
  }

  Note: '''
  對話訊息實體，統一儲存所有渠道的聊天訊息（方案 A：單表 + platform 欄位）

  核心功能：
    1. 記錄客服聊天室中的所有訊息
    2. 支援多渠道訊息整合顯示
    3. 記錄訊息來源以區分人工/自動回應

  訊息來源 (message_source) 說明：
    - webhook：用戶透過渠道主動發送的訊息
    - manual：客服人員手動回覆
    - gpt：GPT 自動生成回應
    - keyword：關鍵字觸發的自動回應
    - welcome：歡迎訊息（新好友加入時）
    - always：全時自動回應
    - broadcast：訊息推播（群發訊息）

  訊息內容存取：
    - 用戶訊息：direction=incoming，內容存於 question 欄位
    - 系統回應：direction=outgoing，內容存於 response 欄位

  與 ChatLog 表的區別：
    - ConversationMessage：客服聊天室使用，包含 message_source 區分回應類型
    - ChatLog：原始訊息日誌備份，包含完整 JSON payload

  關係：ConversationMessage N:1 ConversationThread
  '''
}

Table ChatLog [note: 'DEPRECATED - migration fec53deadf8b 已刪除'] {
  id bigint [pk, increment, note: '聊天記錄唯一識別碼']
  platform string(50) [not null, note: '平台類型：LINE / Facebook / Webchat']
  user_id string(100) [not null, note: '用戶 UID（LINE UID / FB UID / Webchat UID）']
  direction string(20) [not null, note: '訊息方向：incoming（收到）/ outgoing（發出）']
  message_type string(20) [not null, note: '訊息類型：text / image / sticker / flex 等']
  text text [note: '文字內容']
  content text [note: '訊息內容（JSON 格式，儲存完整 payload）。格式：{"type":"<message_type>","data":{...}}']
  event_id string(100) [note: '事件 ID（用於去重與追蹤）']
  status string(20) [note: '狀態']
  created_at timestamp [not null, default: `now()`, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  indexes {
    user_id_index (user_id) [note: '優化用戶訊息查詢']
    platform_user_index (platform, user_id) [note: '優化渠道用戶查詢']
    event_id_index (event_id) [note: '優化事件 ID 查詢（去重用）']
  }

  Note: '''
  聊天記錄實體，作為原始訊息日誌備份

  用途定位：
    - 原始訊息日誌：儲存完整 JSON payload，供除錯和稽核使用
    - 備份層：與 ConversationMessage 同時寫入，互為備份

  與 ConversationMessage 的關係：
    ┌─────────────────────────────────────────────────────────────┐
    │  收到訊息時同時寫入兩表：                                     │
    │  1. ConversationMessage → 客服聊天室顯示（含 message_source） │
    │  2. ChatLog → 原始日誌備份（含完整 JSON payload）             │
    └─────────────────────────────────────────────────────────────┘

  兩表差異對照：
    | 特性           | ConversationMessage        | ChatLog                |
    |----------------|----------------------------|------------------------|
    | 主要用途       | 客服聊天室 UI 顯示          | 原始日誌備份            |
    | message_source | ✅ 有（區分回應類型）        | ❌ 無                   |
    | content        | 分離存於 question/response  | ✅ 完整 JSON payload    |
    | 讀取場景       | 聊天室 API、已讀標記         | 除錯、稽核、資料恢復    |

  content JSON 格式對照：
    - image：{"type":"image","data":{"url":"<string>"}}
    - sticker：{"type":"sticker","data":{"package_id":"<string>","sticker_id":"<string>"}}
    - flex：{"type":"flex","data":{"json":{...}}}
    - video：{"type":"video","data":{"url":"<string>","duration_ms":<number>}}
    - audio：{"type":"audio","data":{"url":"<string>","duration_ms":<number>}}
    - location：{"type":"location","data":{"title":"<string>","address":"<string>","lat":<number>,"lng":<number>}}
    - file：{"type":"file","data":{"url":"<string>","filename":"<string>","size_bytes":<number>}}
    - text：可為 NULL（text 欄位已存），或同格式：{"type":"text","data":{"text":"<string>"}}
  '''
}

// ============================================
// 問卷系統相關資料表
// ============================================

Table SurveyTemplate [note: 'DEPRECATED - 僅有 migration，無 SQLAlchemy model'] {
  id bigint [pk, increment, note: '問卷範本唯一識別碼']
  name string(100) [not null, note: '範本名稱']
  description text [note: '範本描述']
  icon string(50) [note: '範本圖標']
  category string(50) [not null, note: '範本類別']
  default_questions json [note: '預設題目（JSON 格式）']
  is_active bool [not null, note: '是否啟用']
  created_at timestamp [not null, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  Note: '''
  問卷範本實體，定義可重複使用的問卷模板
  用途：提供預設問卷範本，加快問卷建立流程
  範本類別可包含：會員資料收集、滿意度調查、市場調研等
  關係：SurveyTemplate 1:N Survey
  '''
}

Table Survey [note: 'DEPRECATED - 僅有 migration，無 SQLAlchemy model'] {
  id bigint [pk, increment, note: '問卷唯一識別碼']
  name string(200) [not null, note: '問卷名稱']
  template_id bigint [ref: > SurveyTemplate.id, not null, note: '範本 ID']
  description text [note: '問卷描述']
  target_audience string(20) [not null, note: '目標受眾：ALL（所有會員）/ FILTERED（篩選目標對象）']
  target_tags json [note: '目標標籤（JSON 格式）']
  schedule_type string(20) [not null, note: '排程類型：IMMEDIATE（立即發送）/ SCHEDULED（排程發送）']
  scheduled_at timestamp [note: '排程發送時間']
  sent_at timestamp [note: '實際發送時間']
  status string(20) [not null, note: '狀態：draft / scheduled / sending / sent / completed']
  response_count int [note: '回應數']
  view_count int [note: '瀏覽數']
  created_by bigint [ref: > User.id, note: '創建者 ID']
  created_at timestamp [not null, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  indexes {
    template_id_index (template_id) [note: '優化範本關聯查詢']
    created_by_index (created_by) [note: '優化創建者查詢']
  }

  Note: '''
  問卷實體，管理問卷的基本資訊與發送狀態
  用途：建立、管理、發送問卷給會員
  問卷狀態流程：draft → scheduled → sending → sent → completed
  關係：Survey N:1 SurveyTemplate, Survey 1:N SurveyQuestion, Survey 1:N SurveyResponse, Survey N:1 User
  '''
}

Table SurveyQuestion [note: 'DEPRECATED - 僅有 migration，無 SQLAlchemy model'] {
  id bigint [pk, increment, note: '題目唯一識別碼']
  survey_id bigint [ref: > Survey.id, not null, note: '問卷 ID']
  question_type string(20) [not null, note: '題目類型：NAME / PHONE / EMAIL / BIRTHDAY / ADDRESS / GENDER / ID_NUMBER / LINK / VIDEO / IMAGE']
  question_text text [not null, note: '題目文字']
  font_size int [note: '字型大小']
  description text [note: '題目描述']
  options json [note: '選項（JSON 格式，用於選擇題）']
  is_required bool [not null, note: '是否必填']
  min_length int [note: '最小長度（文字輸入題）']
  max_length int [note: '最大長度（文字輸入題）']
  min_value int [note: '最小值（數值題）']
  max_value int [note: '最大值（數值題）']
  order int [not null, note: '題目順序']
  video_description text [note: '影片描述']
  video_link string(500) [note: '影片超連結']
  image_description text [note: '圖片描述']
  image_link string(500) [note: '圖片連結（編輯使用）']
  image_base64 text [note: '圖片 Base64（發送使用）']
  created_at timestamp [not null, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  indexes {
    survey_id_index (survey_id) [note: '優化問卷題目查詢']
  }

  Note: '''
  問卷題目實體，定義問卷中的每個題目
  題目類型說明：
    - NAME：姓名輸入
    - PHONE：電話輸入
    - EMAIL：電子信箱輸入
    - BIRTHDAY：生日輸入
    - ADDRESS：地址輸入
    - GENDER：性別選擇
    - ID_NUMBER：身分證輸入
    - LINK：超連結顯示
    - VIDEO：影片顯示
    - IMAGE：圖片顯示
  關係：SurveyQuestion N:1 Survey
  '''
}

Table SurveyResponse [note: 'DEPRECATED - 僅有 migration，無 SQLAlchemy model'] {
  id bigint [pk, increment, note: '回覆唯一識別碼']
  survey_id bigint [ref: > Survey.id, not null, note: '問卷 ID']
  member_id bigint [ref: > Member.id, not null, note: '會員 ID']
  answers json [not null, note: '答案（JSON 格式）']
  is_completed bool [not null, note: '是否完成']
  completed_at timestamp [note: '完成時間']
  source string(50) [note: '來源：LINE / Web / SMS 等']
  ip_address string(50) [note: 'IP 位址']
  user_agent string(500) [note: '用戶代理']
  created_at timestamp [not null, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  indexes {
    survey_id_index (survey_id) [note: '優化問卷回覆查詢']
    member_id_index (member_id) [note: '優化會員回覆查詢']
  }

  Note: '''
  問卷回覆實體，記錄會員的問卷填答資料
  用途：儲存會員對問卷的回覆內容，支援會員資料自動更新
  answers 欄位格式：{"question_id": "answer_value", ...}
  關係：SurveyResponse N:1 Survey, SurveyResponse N:1 Member
  '''
}

// ============================================
// 使用者管理相關資料表
// ============================================

Table User {
  id bigint [pk, increment, note: '使用者唯一識別碼']
  username string(50) [unique, not null, note: '用戶名']
  email string(100) [unique, not null, note: '電子信箱']
  password_hash string(255) [not null, note: '密碼雜湊值']
  full_name string(100) [note: '全名']
  role string(20) [not null, note: '角色：ADMIN（管理員）/ MARKETING（行銷人員）/ CUSTOMER_SERVICE（客服人員）']
  is_active bool [note: '是否啟用']
  last_login_at timestamp [note: '最後登入時間']
  created_at timestamp [not null, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  Note: '''
  使用者實體，管理系統操作人員帳號
  用途：提供系統登入、權限控制功能
  角色說明：
    - ADMIN：管理員，擁有所有權限
    - MARKETING：行銷人員，可操作群發訊息、活動管理
    - CUSTOMER_SERVICE：客服人員，可操作聊天室、會員查詢
  遷移策略：
    - User 為後續唯一帳號表，逐步取代 Admin（含帳號與權限資料的遷移）
    - 過渡期間：Admin/RBAC 仍為正式權限來源，維持 Admin 與 User 帳號 1:1 同步（同 email），以便平滑遷移
    - 新功能與外鍵（如 Survey.created_by）一律參照 User，為後續淘汰 Admin 做準備
  關係：User 1:N Survey（創建者）
  '''
}

// ============================================
// 標籤觸發記錄相關資料表
// ============================================

Table TagTriggerLog {
  id bigint [pk, increment, note: '觸發記錄唯一識別碼']
  member_id bigint [ref: > Member.id, not null, note: '會員 ID']
  tag_id bigint [ref: > InteractionTag.id, not null, note: '標籤 ID']
  message_id bigint [ref: > Message.id, note: '群發訊息 ID（選填）']
  campaign_id bigint [ref: > Campaign.id, note: '活動 ID（選填）']
  trigger_source string(20) [not null, note: '觸發來源：CLICK（按鈕點擊）/ INTERACTION（互動）/ MANUAL（手動）']
  triggered_at timestamp [not null, note: '觸發時間']
  created_at timestamp [not null, note: '建立時間（UTC）']
  updated_at timestamp [note: '更新時間（UTC）']

  indexes {
    member_id_index (member_id) [note: '優化會員標籤查詢']
    tag_id_index (tag_id) [note: '優化標籤統計查詢']
    message_id_index (message_id) [note: '優化訊息關聯查詢']
    campaign_id_index (campaign_id) [note: '優化活動關聯查詢']
  }

  Note: '''
  標籤觸發記錄實體，記錄會員觸發標籤的詳細歷史
  用途：追蹤會員互動行為，支援標籤統計與分析
  觸發來源說明：
    - CLICK：會員點擊訊息中的按鈕
    - INTERACTION：會員與訊息互動
    - MANUAL：管理員手動為會員打標籤
  與 ComponentInteractionLog 的區別：
    - TagTriggerLog：標籤維度的觸發記錄，用於標籤統計
    - ComponentInteractionLog：訊息元件維度的互動記錄，用於互動分析
  關係：TagTriggerLog N:1 Member, TagTriggerLog N:1 InteractionTag, TagTriggerLog N:1 Message（選填）, TagTriggerLog N:1 Campaign（選填）
  '''
}
