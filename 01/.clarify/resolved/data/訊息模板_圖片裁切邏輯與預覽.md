# 釐清項目：訊息模板_圖片裁切邏輯與預覽

## 基本資訊
- **優先級**：Medium
- **類別**：功能模型
- **相關檔案**：
  - `spec/erm.dbml` (MessageTemplate.image_url)
  - `spec/features/create_broadcast.feature` (即時預覽功能)
  - `spec/requirement_push_message.md`

## 問題描述

現有規格定義了圖片相關規則：
- `MessageTemplate.image_url` - **圖片比例 1:1（後端自動裁切為正方形，取中心區域），檔案大小 <= 1 MB**
- 支援**訊息效果的即時模擬與預覽功能**
- **配置區填寫內容，預覽區即時渲染預覽**

但規格中未明確定義：

1. **裁切執行位置**：圖片裁切由前端執行還是後端執行？
2. **裁切時機**：上傳時裁切、儲存時裁切，還是顯示時裁切？
3. **裁切邏輯細節**：「取中心區域」的具體算法？非正方形圖片（如 16:9, 4:3）如何裁切？
4. **預覽顯示**：預覽時顯示原圖還是裁切後的圖？
5. **儲存策略**：儲存原圖 URL 還是裁切後圖片 URL？
6. **檔案大小驗證**：1 MB 限制在何時檢查？原圖還是裁切後？

## 影響範圍

- **功能影響**：圖片上傳流程、訊息預覽準確性、LINE 訊息顯示效果
- **使用者體驗**：上傳等待時間、預覽即時性、圖片顯示品質
- **技術架構**：前後端職責劃分、圖片處理邏輯、儲存空間使用
- **系統效能**：前端處理負擔、後端處理負擔、網路傳輸量

## 選項分析

### 選項 A：前端裁切 + 上傳裁切後圖片

**執行位置**：前端（瀏覽器）

**流程**：
1. 使用者選擇圖片檔案
2. **前端 JavaScript 讀取圖片**
3. **前端計算裁切區域**（取中心正方形）
4. **前端執行裁切**（Canvas API）
5. **前端即時預覽裁切後圖片**
6. 使用者點擊「儲存」或「上傳」
7. **前端上傳裁切後的圖片到伺服器**
8. 後端儲存圖片並返回 URL
9. 前端將 URL 儲存到 image_url 欄位

**裁切算法**（前端 Canvas）：
```javascript
// 假設原圖寬高為 width, height
const size = Math.min(width, height);  // 取較小邊作為正方形邊長
const x = (width - size) / 2;          // 中心X座標
const y = (height - size) / 2;         // 中心Y座標
// 裁切區域：(x, y, size, size)
```

**檔案大小檢查**：前端檢查原圖大小，若 > 1 MB 顯示錯誤

**儲存內容**：裁切後圖片的 URL

**優點**：
- ✅ 即時預覽（無需等待後端處理）
- ✅ 減少上傳流量（只上傳裁切後的小圖）
- ✅ 後端處理簡單（只需儲存圖片）
- ✅ 預覽與實際顯示100%一致

**缺點**：
- ❌ 前端處理負擔較重（大圖片可能卡頓）
- ❌ 無法保留原圖（若需要重新裁切需重新上傳）
- ❌ 瀏覽器相容性問題（需處理 Canvas API 支援）

**適用情境**：
- 重視即時預覽體驗
- 上傳流量有限制
- 不需要保留原圖

---

### 選項 B：前端裁切 + 上傳雙圖片（原圖 + 裁切圖）

**執行位置**：前端（瀏覽器）

**流程**：
1. 使用者選擇圖片檔案
2. 前端讀取圖片並執行裁切
3. **前端即時預覽裁切後圖片**
4. 使用者點擊「儲存」
5. **前端同時上傳原圖和裁切後圖片**
6. 後端儲存兩張圖片，返回兩個 URL
7. 前端將**裁切圖 URL 儲存到 image_url**，原圖 URL 儲存到 `original_image_url`（新欄位）

**資料模型變更**：
```dbml
Table MessageTemplate {
  image_url string [note: '裁切後圖片 URL（正方形 1:1）']
  original_image_url string [note: '原始圖片 URL（選填），用於重新裁切或查看原圖']
}
```

**優點**：
- ✅ 即時預覽
- ✅ 保留原圖（可重新裁切）
- ✅ 預覽與實際顯示一致

**缺點**：
- ❌ 上傳兩張圖片，流量翻倍
- ❌ 儲存空間翻倍
- ❌ 前端處理複雜度高

**適用情境**：
- 需要保留原圖功能
- 儲存空間充足

---

### 選項 C：後端裁切 + 前端預覽模擬（推薦）

**執行位置**：後端（伺服器）

**流程**：
1. 使用者選擇圖片檔案
2. **前端使用 CSS object-fit: cover 模擬裁切預覽**（不實際裁切）
3. 使用者點擊「儲存」
4. **前端上傳原圖到後端**
5. **後端接收原圖並執行裁切**（使用 PIL, ImageMagick, Sharp 等）
6. **後端儲存裁切後圖片**，返回裁切圖 URL
7. 前端將 URL 儲存到 image_url 欄位
8. **前端重新載入裁切後圖片顯示在預覽區**

**裁切算法**（後端 Python PIL 範例）：
```python
from PIL import Image

def crop_to_square(image_path):
    img = Image.open(image_path)
    width, height = img.size
    size = min(width, height)

    # 計算裁切區域（取中心）
    left = (width - size) // 2
    top = (height - size) // 2
    right = left + size
    bottom = top + size

    # 裁切並返回
    return img.crop((left, top, right, bottom))
```

**前端預覽模擬**（CSS）：
```css
.image-preview {
  width: 300px;
  height: 300px;
  object-fit: cover;  /* 模擬裁切效果 */
  object-position: center;
}
```

**檔案大小檢查**：
- 前端檢查原圖 <= 1 MB（初步驗證）
- 後端檢查原圖 <= 1 MB（最終驗證）

**儲存內容**：裁切後圖片的 URL

**優點**：
- ✅ 前端處理簡單（只負責上傳和 CSS 預覽）
- ✅ 後端裁切品質更好（專業圖片處理庫）
- ✅ 前端不受大圖片卡頓影響
- ✅ 減少前端 JavaScript 複雜度

**缺點**：
- ❌ 預覽不是100%準確（CSS 模擬 vs 實際裁切）
- ❌ 需要上傳完整原圖（流量較大）
- ❌ 上傳後需等待後端處理（有延遲）
- ❌ 無法保留原圖（若需要重新裁切需重新上傳）

**適用情境**：
- 追求後端處理品質
- 前端技術棧簡單化
- 可接受輕微預覽誤差

---

### 選項 D：後端裁切 + 保留原圖 + 前端預覽模擬

**執行位置**：後端（伺服器）

**流程**：
1. 使用者選擇圖片檔案
2. 前端使用 CSS 模擬裁切預覽
3. 使用者點擊「儲存」
4. 前端上傳原圖到後端
5. **後端同時儲存原圖和裁切後圖片**
6. 後端返回兩個 URL（original_image_url, image_url）
7. 前端儲存兩個 URL
8. 前端重新載入裁切後圖片顯示

**資料模型變更**：
```dbml
Table MessageTemplate {
  image_url string [note: '裁切後圖片 URL（正方形 1:1），用於實際發送到 LINE']
  original_image_url string [note: '原始圖片 URL（選填），用於重新裁切或編輯時預覽']
}
```

**優點**：
- ✅ 保留原圖（可重新裁切）
- ✅ 後端處理品質好
- ✅ 支援未來擴展（如：自訂裁切位置）

**缺點**：
- ❌ 儲存空間翻倍
- ❌ 後端處理複雜度較高
- ❌ 預覽不是100%準確

**適用情境**：
- 需要保留原圖功能
- 可能需要重新裁切
- 儲存空間充足

---

## 推薦方案

**推薦選項 C：後端裁切 + 前端預覽模擬**

**推薦理由**：

1. **前後端職責清晰**：前端負責 UI 與上傳，後端負責圖片處理
2. **處理品質更好**：後端使用專業圖片處理庫（PIL, ImageMagick, Sharp）
3. **前端簡單化**：避免複雜的 Canvas 處理邏輯
4. **效能平衡**：前端不受大圖片影響，後端處理也不複雜
5. **成本最低**：無需儲存兩張圖片

**次要推薦選項 A**（若特別重視即時預覽）：
- 前端裁切可提供100%準確的預覽
- 適合前端技術能力強的團隊

---

## 設計細節（基於推薦選項 C）

### 前端實作

**圖片上傳與預覽**：

```html
<template>
  <div class="image-upload">
    <!-- 圖片上傳區 -->
    <input type="file" accept="image/*" @change="handleImageSelect" />

    <!-- 預覽區（使用 CSS 模擬裁切） -->
    <div class="preview-container">
      <img :src="previewUrl" class="image-preview" alt="預覽" />
      <p class="preview-hint">預覽（實際發送時將裁切為正方形）</p>
    </div>
  </div>
</template>

<style>
.image-preview {
  width: 300px;
  height: 300px;
  object-fit: cover;        /* 模擬裁切效果 */
  object-position: center;  /* 取中心區域 */
  border: 2px dashed #ccc;
}
</style>

<script>
export default {
  methods: {
    handleImageSelect(event) {
      const file = event.target.files[0];

      // 檢查檔案大小
      if (file.size > 1024 * 1024) {
        alert('圖片檔案大小不可超過 1 MB');
        return;
      }

      // 建立預覽 URL
      this.previewUrl = URL.createObjectURL(file);

      // 上傳到後端
      this.uploadImage(file);
    },

    async uploadImage(file) {
      const formData = new FormData();
      formData.append('image', file);

      const response = await fetch('/api/v1/upload-image', {
        method: 'POST',
        body: formData
      });

      const data = await response.json();

      // 儲存裁切後圖片 URL
      this.imageUrl = data.cropped_image_url;

      // 更新預覽（顯示實際裁切後的圖片）
      this.previewUrl = data.cropped_image_url;
    }
  }
}
</script>
```

### 後端實作（Python FastAPI + PIL 範例）

```python
from fastapi import UploadFile, HTTPException
from PIL import Image
import io

@app.post("/api/v1/upload-image")
async def upload_image(image: UploadFile):
    # 檢查檔案大小
    contents = await image.read()
    if len(contents) > 1024 * 1024:  # 1 MB
        raise HTTPException(status_code=400, detail="圖片檔案大小不可超過 1 MB")

    # 開啟圖片
    img = Image.open(io.BytesIO(contents))

    # 裁切為正方形（取中心區域）
    width, height = img.size
    size = min(width, height)

    left = (width - size) // 2
    top = (height - size) // 2
    right = left + size
    bottom = top + size

    cropped_img = img.crop((left, top, right, bottom))

    # 儲存裁切後圖片
    cropped_path = f"uploads/cropped_{image.filename}"
    cropped_img.save(cropped_path)

    # 返回 URL
    cropped_url = f"https://yourdomain.com/{cropped_path}"

    return {
        "cropped_image_url": cropped_url
    }
```

### 功能規則新增

**create_broadcast.feature 或新增 message_template.feature**：

```gherkin
Rule: 圖片上傳後由後端自動裁切為正方形（1:1 比例）

  Example: 上傳橫向圖片（16:9）自動裁切
    Given 行銷人員正在建立訊息模板
    When 行銷人員上傳橫向圖片「banner.jpg」（尺寸：1600x900）
    Then 前端顯示 CSS 模擬預覽（300x300 正方形，取中心區域）
    And 前端上傳圖片到後端
    And 後端計算裁切區域：取中心 900x900 正方形
    And 後端裁切圖片並儲存
    And 後端返回裁切後圖片 URL
    And 前端更新 image_url 為裁切後圖片 URL
    And 前端重新載入裁切後圖片顯示在預覽區

  Example: 上傳直向圖片（9:16）自動裁切
    Given 行銷人員正在建立訊息模板
    When 行銷人員上傳直向圖片「portrait.jpg」（尺寸：900x1600）
    Then 後端計算裁切區域：取中心 900x900 正方形
    And 後端裁切圖片並儲存
    And 前端顯示裁切後圖片（正方形）

  Example: 上傳已是正方形圖片（1:1）
    Given 行銷人員正在建立訊息模板
    When 行銷人員上傳正方形圖片「square.jpg」（尺寸：800x800）
    Then 後端不需裁切（已是正方形）
    And 後端直接儲存原圖
    And 前端顯示原圖

Rule: 圖片檔案大小限制為 1 MB

  Example: 上傳檔案大小超過 1 MB
    Given 行銷人員正在上傳圖片
    When 行銷人員選擇檔案大小為「1.5 MB」的圖片
    Then 前端顯示錯誤訊息「圖片檔案大小不可超過 1 MB」
    And 前端阻擋上傳操作

  Example: 上傳檔案大小符合限制
    Given 行銷人員正在上傳圖片
    When 行銷人員選擇檔案大小為「800 KB」的圖片
    Then 前端允許上傳
    And 後端接收並處理圖片

Rule: 前端使用 CSS 模擬裁切預覽

  Example: 上傳前預覽模擬裁切效果
    Given 行銷人員選擇了橫向圖片「banner.jpg」
    When 前端顯示預覽
    Then 前端使用 CSS object-fit: cover 顯示圖片
    And 前端設定 object-position: center 取中心區域
    And 預覽區顯示正方形圖片（模擬裁切效果）
    And 預覽區顯示提示文字「預覽（實際發送時將裁切為正方形）」

Rule: 前端上傳完成後重新載入實際裁切後圖片

  Example: 上傳完成後更新預覽為實際裁切圖
    Given 行銷人員已上傳圖片「banner.jpg」
    And 後端已完成裁切並返回 URL「https://cdn.com/cropped_banner.jpg」
    When 前端接收到後端返回的 URL
    Then 前端更新 image_url 為「https://cdn.com/cropped_banner.jpg」
    And 前端重新載入該 URL 的圖片顯示在預覽區
    And 預覽區顯示實際裁切後的圖片（100%準確）
```

---

## 後續影響

### 需同步更新的規格檔案
1. **spec/erm.dbml**：MessageTemplate.image_url 欄位說明更新（明確後端裁切）
2. **spec/features/create_broadcast.feature** 或新增 **message_template.feature**：新增圖片裁切與預覽規則

### 需考慮的技術實作
1. **後端圖片處理庫**：Python PIL / Node.js Sharp / Go imaging
2. **前端 CSS 預覽**：object-fit: cover + object-position: center
3. **檔案上傳**：FormData 上傳、進度條顯示
4. **錯誤處理**：檔案過大、格式不支援、上傳失敗

### 相關釐清項目
- **會員管理_頭像圖片儲存與更新機制**（Medium 優先級）- 可能採用相同圖片處理策略

---

## 決策記錄
- **決策日期**：2025-01-13
- **決策者**：專案團隊
- **選擇方案**：選項 C - 後端裁切 + 前端預覽模擬
- **決策理由**：
  1. 前後端職責清晰：前端負責 UI 與上傳，後端負責圖片處理
  2. 處理品質更好：後端使用專業圖片處理庫（PIL, ImageMagick, Sharp）
  3. 前端簡單化：避免複雜的 Canvas 處理邏輯
  4. 效能平衡：前端不受大圖片影響，後端處理也不複雜
  5. 成本最低：無需儲存兩張圖片

## 實作內容
- **已更新 spec/erm.dbml**：MessageTemplate.image_url 欄位說明更新，明確圖片處理流程
- **已更新 spec/features/create_broadcast.feature**：新增 4 個 Rule with 8 個 Examples 涵蓋圖片裁切、檔案驗證、CSS 預覽模擬
