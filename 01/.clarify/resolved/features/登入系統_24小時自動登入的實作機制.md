# 釐清問題

「24HR 內保持自動登入」的實作機制為何？使用 Cookie、LocalStorage、Session，還是 JWT Token？

# 定位

Feature：spec/features/登入系統.feature Rule 標記為 #TODO（約第57-63行）

# 多選題

| 選項 | 描述 |
|--------|-------------|
| A | 使用 HTTP-only Cookie 儲存 Session ID，伺服器端維護 Session |
| B | 使用 JWT Token 儲存於 LocalStorage，每次請求帶入 Authorization Header |
| C | 混合模式：短期 Session（1小時）+ Refresh Token（24小時） |
| Short | 其他機制（<=5字）|

# 影響範圍

影響前後端架構設計、安全性等級、跨域請求處理、Token 刷新邏輯，以及無狀態服務擴展性。

# 優先級

High

---

# 用戶決策

**決策日期：** 2025-11-12

**決策內容：** B - 使用 JWT Token 儲存於 LocalStorage，每次請求帶入 Authorization Header

**用戶原話：** "B"

# 規格整合

## 新增內容

### spec/features/登入系統.feature

#### 更新 Rule：登入成功後建立會話，24HR 內保持自動登入（第 57-90 行）

將原本的 `#TODO` 替換為以下完整規格：

```gherkin
Rule: 登入成功後建立會話，24HR 內保持自動登入

  Example: 登入成功後產生 JWT Token
    Given 管理員「李經理」輸入正確的信箱與密碼
    When 登入成功
    Then 系統產生 JWT Token，包含以下資訊
      | 欄位         | 說明                     |
      | admin_id     | 管理員 ID                |
      | email        | 管理員信箱               |
      | iat          | Token 發行時間           |
      | exp          | Token 過期時間（24小時後）|
    And 系統將 JWT Token 回傳給前端
    And 前端將 JWT Token 儲存於 LocalStorage

  Example: 前端 API 請求自動帶入 JWT Token
    Given 管理員已登入，LocalStorage 中存在有效的 JWT Token
    When 前端發送 API 請求
    Then 請求的 Authorization Header 包含「Bearer {JWT_TOKEN}」
    And 伺服器驗證 JWT Token 的簽章與有效期
    And Token 有效時，請求成功執行
    And Token 無效或過期時，回傳 401 Unauthorized

  Example: JWT Token 在 24 小時內保持有效
    Given 管理員於「2025/11/12 10:00」登入成功並取得 JWT Token
    When 管理員於「2025/11/13 09:59」（23小時59分後）發送 API 請求
    Then 系統驗證 Token 仍在有效期內
    And 請求成功執行

  Example: JWT Token 超過 24 小時後失效
    Given 管理員於「2025/11/12 10:00」登入成功並取得 JWT Token
    When 管理員於「2025/11/13 10:01」（24小時1分後）發送 API 請求
    Then 系統驗證 Token 已過期
    And 回傳 401 Unauthorized
    And 前端導向登入頁面，提示「登入已過期，請重新登入」
```

## 實作說明

### 後端實作（FastAPI + PyJWT）

#### 1. JWT Token 生成

```python
from datetime import datetime, timedelta
import jwt
from typing import Dict

# JWT 設定
SECRET_KEY = "your-secret-key-here"  # 應從環境變數讀取
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_HOURS = 24

def create_access_token(data: Dict) -> str:
    """
    產生 JWT Access Token

    Args:
        data: 要編碼的資料（如 admin_id, email）

    Returns:
        JWT Token 字串
    """
    to_encode = data.copy()

    # 設定發行時間和過期時間
    iat = datetime.utcnow()
    exp = iat + timedelta(hours=ACCESS_TOKEN_EXPIRE_HOURS)

    to_encode.update({
        "iat": iat,
        "exp": exp
    })

    # 編碼生成 JWT Token
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
```

#### 2. 登入 API 端點

```python
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel

router = APIRouter()

class LoginRequest(BaseModel):
    email: str
    password: str

class LoginResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    admin_id: int
    email: str

@router.post("/login", response_model=LoginResponse)
async def login(credentials: LoginRequest):
    """管理員登入端點"""

    # 驗證帳號密碼
    admin = authenticate_admin(credentials.email, credentials.password)
    if not admin:
        raise HTTPException(
            status_code=401,
            detail="信箱或密碼錯誤"
        )

    # 產生 JWT Token
    access_token = create_access_token(
        data={
            "admin_id": admin.id,
            "email": admin.email
        }
    )

    return LoginResponse(
        access_token=access_token,
        admin_id=admin.id,
        email=admin.email
    )
```

#### 3. JWT Token 驗證中間件

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt

security = HTTPBearer()

async def get_current_admin(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> Dict:
    """
    驗證 JWT Token 並取得當前管理員資訊

    在需要身份驗證的 API 端點使用此依賴注入
    """
    token = credentials.credentials

    try:
        # 驗證並解碼 JWT Token
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

        # 檢查 Token 是否包含必要欄位
        admin_id = payload.get("admin_id")
        email = payload.get("email")

        if admin_id is None or email is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token 格式不正確"
            )

        return {
            "admin_id": admin_id,
            "email": email
        }

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="登入已過期，請重新登入"
        )
    except jwt.JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="無效的身份驗證憑證"
        )
```

#### 4. 保護的 API 端點範例

```python
@router.get("/campaigns")
async def get_campaigns(
    current_admin: Dict = Depends(get_current_admin)
):
    """取得群發訊息列表（需要身份驗證）"""
    admin_id = current_admin["admin_id"]

    # 查詢該管理員的群發訊息
    campaigns = get_campaigns_by_admin(admin_id)
    return campaigns
```

### 前端實作（React + Axios）

#### 1. 登入功能

```typescript
// services/auth.ts
import axios from 'axios';

interface LoginCredentials {
  email: string;
  password: string;
}

interface LoginResponse {
  access_token: string;
  token_type: string;
  admin_id: number;
  email: string;
}

export const login = async (credentials: LoginCredentials): Promise<LoginResponse> => {
  const response = await axios.post<LoginResponse>('/api/login', credentials);

  // 將 JWT Token 儲存到 LocalStorage
  localStorage.setItem('access_token', response.data.access_token);
  localStorage.setItem('admin_id', response.data.admin_id.toString());
  localStorage.setItem('email', response.data.email);

  return response.data;
};

export const logout = () => {
  // 清除 LocalStorage 中的 Token
  localStorage.removeItem('access_token');
  localStorage.removeItem('admin_id');
  localStorage.removeItem('email');
};

export const getAccessToken = (): string | null => {
  return localStorage.getItem('access_token');
};

export const isAuthenticated = (): boolean => {
  return !!getAccessToken();
};
```

#### 2. Axios 攔截器（自動帶入 Token）

```typescript
// services/api.ts
import axios from 'axios';
import { getAccessToken, logout } from './auth';

// 建立 Axios 實例
const api = axios.create({
  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:8000/api',
});

// 請求攔截器：自動加入 Authorization Header
api.interceptors.request.use(
  (config) => {
    const token = getAccessToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 回應攔截器：處理 401 錯誤
api.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    if (error.response?.status === 401) {
      // Token 過期或無效，清除並導向登入頁
      logout();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

#### 3. 登入頁面組件

```typescript
// pages/Login.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { login } from '../services/auth';

const LoginPage: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    try {
      await login({ email, password });

      // 登入成功，導向首頁
      navigate('/');
    } catch (err: any) {
      setError(err.response?.data?.detail || '登入失敗');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="信箱"
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="密碼"
        required
      />
      {error && <div className="error">{error}</div>}
      <button type="submit">登入</button>
    </form>
  );
};

export default LoginPage;
```

#### 4. 路由守衛（Protected Route）

```typescript
// components/ProtectedRoute.tsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { isAuthenticated } from '../services/auth';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  if (!isAuthenticated()) {
    // 未登入，導向登入頁
    return <Navigate to="/login" />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;

// 使用方式（在 App.tsx）
<Route
  path="/campaigns"
  element={
    <ProtectedRoute>
      <CampaignsPage />
    </ProtectedRoute>
  }
/>
```

### JWT Token 結構範例

```json
{
  "admin_id": 123,
  "email": "admin@example.com",
  "iat": 1699776000,
  "exp": 1699862400
}
```

編碼後的 JWT Token（三段式，以 `.` 分隔）：
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbl9pZCI6MTIzLCJlbWFpbCI6ImFkbWluQGV4YW1wbGUuY29tIiwiaWF0IjoxNjk5Nzc2MDAwLCJleHAiOjE2OTk4NjI0MDB9.signature
```

### 安全性考量

#### 1. XSS 防護
- **風險：** LocalStorage 容易受到 XSS 攻擊
- **緩解措施：**
  - 嚴格的 Content Security Policy (CSP)
  - 輸入驗證和輸出編碼
  - 定期安全審計
  - 避免使用 `eval()` 和 `innerHTML`

#### 2. Token 洩漏風險
- **風險：** Token 一旦洩漏，在有效期內都可被使用
- **緩解措施：**
  - 使用 HTTPS 加密傳輸
  - 設定合理的過期時間（24小時）
  - 考慮實作 Token 黑名單機制（用於強制登出）

#### 3. CORS 設定
```python
# FastAPI CORS 設定
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # 前端網址
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

### 優點
- **無狀態：** 伺服器不需儲存 Session，易於水平擴展
- **跨域支援：** 適合前後端分離架構
- **微服務友善：** Token 可在不同服務間共用（相同 SECRET_KEY）
- **行動端友善：** 行動 App 也可使用相同機制

### 缺點
- **無法即時撤銷：** Token 在有效期內無法撤銷（除非引入黑名單）
- **安全性較低：** LocalStorage 容易受 XSS 攻擊
- **Token 大小：** JWT Token 較大，每次請求都需傳輸

### 建議改進（未來擴充）

#### 1. 實作 Refresh Token 機制
```python
# 短期 Access Token (1小時) + 長期 Refresh Token (24小時)
ACCESS_TOKEN_EXPIRE_MINUTES = 60
REFRESH_TOKEN_EXPIRE_HOURS = 24

@router.post("/refresh")
async def refresh_token(refresh_token: str):
    """使用 Refresh Token 取得新的 Access Token"""
    # 驗證 Refresh Token
    # 產生新的 Access Token
    pass
```

#### 2. Token 黑名單機制（用於強制登出）
```python
# 使用 Redis 儲存已撤銷的 Token
import redis

redis_client = redis.Redis(host='localhost', port=6379)

def revoke_token(token: str, exp: int):
    """將 Token 加入黑名單"""
    ttl = exp - int(datetime.utcnow().timestamp())
    redis_client.setex(f"blacklist:{token}", ttl, "1")

def is_token_revoked(token: str) -> bool:
    """檢查 Token 是否已被撤銷"""
    return redis_client.exists(f"blacklist:{token}")
```

### 測試要點
1. **登入成功測試：** 驗證登入後取得有效的 JWT Token
2. **Token 儲存測試：** 驗證 Token 正確儲存到 LocalStorage
3. **API 請求測試：** 驗證 API 請求自動帶入 Authorization Header
4. **Token 驗證測試：** 驗證伺服器正確驗證 Token
5. **過期測試：** 驗證 Token 過期後回傳 401 並導向登入頁
6. **登出測試：** 驗證登出後清除 LocalStorage 並無法存取 API
7. **路由守衛測試：** 驗證未登入時無法存取受保護的頁面

# 歸檔資訊

- **歸檔時間：** 2025-11-12
- **處理狀態：** 已整合至規格
- **處理者：** Claude (SuperClaude Framework)
