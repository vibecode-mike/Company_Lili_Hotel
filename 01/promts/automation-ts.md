# Automation：從完整規格自動化開發至可部署應用

---

## 技術堆疊配置（可自定義）

**使用者可以修改此區域來指定不同的技術堆，本 prompt 適用於任何技術組合**

### 預設技術堆疊（Next.js Full-Stack）

```yaml
# 程式語言
language: TypeScript

# 前端框架與工具
frontend:
  framework: Next.js 14 (App Router)
  ui_library: React 18
  styling: Tailwind CSS
  state_management: React Hooks (useState, useContext)
  http_client: fetch API (內建)
  form_handling: 原生 HTML Forms

# 後端框架與工具
backend:
  framework: Next.js API Routes / Route Handlers
  runtime: Node.js
  validation: 手動驗證（或輕量級 schema validator）

# 資料庫
database:
  type: PostgreSQL 15
  client: pg (node-postgres)
  migration: 手動 SQL 腳本 (init.sql)

# 容器化
containerization:
  app: Docker
  orchestration: Docker Compose
  base_image: node:18-alpine

# 開發工具
dev_tools:
  package_manager: npm
  linter: ESLint (預設配置)
  formatter: Prettier (選用)
```

**說明**：
- 以上是建議的預設組合，強調**簡單、快速、少依賴**
- 使用者可根據需求替換任何工具（例如：換成 Express + React、Python + Django、Java + Spring Boot 等）
- 無論使用何種技術棧，核心目標不變：**正確實作所有規格定義的功能**

---

## 快速摘要

**最重要的事情**：功能正確 >>> 程式碼架構
- 用最簡單的方式，正確實作所有規則（依 Feature Files 中的 Rule 數量）
- 前端要清楚展示所有業務規則的計算過程與驗證結果
- 測試資料要充足（至少涵蓋各種測試場景所需的基礎資料）
- 實際部署並測試，確認規則計算正確

**要做的**：
- 實作 `spec/features/` 中定義的所有功能
- 正確實作所有業務規則與計算邏輯
- 前端顯示規則計算過程（不只是最終結果）
- 建立豐富的測試資料（init.sql）

**不要做的**：
- 不要花時間設計複雜架構
- 不要實作規格中未提及的功能
- 不要腦補規格沒提到的功能

---

## 目標
基於 `spec/` 資料夾中的完整規格，使用**上述指定的技術棧**，開發一個**功能完整、正確實作所有規則**的前後端應用程式，並完成 Docker 容器化部署。

**核心目標：讓觀眾透過網頁操作，親眼驗證所有 Feature File 中的 Examples 都被正確實作。**

---

## 功能範疇

### 需要實作的功能
- 實作 `spec/features/` 資料夾中的所有 `.feature` 檔案定義的功能
- 每個 Feature 中的所有 Rules 都必須完整實作

### 不需要實作的功能
- 規格中未明確提及的功能（例如：若規格未要求登入系統，則不實作）
- 規格中標註為「未來功能」或「選用功能」的項目
- 任何規格以外的「可能需要」的功能

---

## 核心原則

### 1. 功能正確性絕對優先
**功能正確性 >>> 程式碼架構品質**

- **每一條規則都必須 100% 正確實作**
- 優先確保業務邏輯完全符合規格，程式碼架構採用最簡單可行的方式即可
- 不需要過度設計：Repository Pattern、DDD、Clean Architecture 等都非必要
- 可以用最直覺的方式實作，重點是**規則對、計算對、展示對**

### 2. 絕對忠於規格原則
**嚴格遵守 `spec/` 資料夾中的所有規格內容，禁止任何腦補、假設或擴充。**

- 只實作 `spec/erm.dbml` 中定義的資料實體與屬性
- 只實作 `spec/features/*.feature` 中定義的功能與規則
- ERM 或 Feature Files 中沒有寫的內容，**絕對不准出現在程式碼中**
- 不添加「可能需要的欄位」「預留功能」「合理的優化」
- 不實作規格中未提及的驗證、邏輯或 UI 元素

### 3. 規則可追溯性原則
- 在實作業務邏輯的程式碼中（無論是 Service、API Route 或其他地方），**必須將每條規則以註解形式逐條抄寫**
- 每個規則對應的實作邏輯必須清晰標註，確保規格與程式碼的 1:1 對應關係

### 4. 資料模型嚴格對應原則
- 資料庫 Schema 必須完整對應 `spec/erm.dbml`
- 所有 ERM 中的約束條件（note 中的限制）都必須使用 **SQL Constraints** 實作
- 屬性的資料型別、唯一性、外鍵關係都必須在資料庫層面強制執行

### 5. 前端完整展示原則（重點）
**前端是展示功能正確性的關鍵，觀眾要能透過前端驗證所有規則**

- 前端 UI 必須能夠**完整展示** `spec/features/*.feature` 中的所有 Examples
- 每個 Rule 的驗證結果都要清楚顯示
- 觀眾應能透過網頁操作，重現 Feature File 中的任一 Example 場景
- 關鍵資訊必須清楚顯示（依規格內容調整，以下為常見範例）：
  - 主要實體的屬性資訊（依 ERM 定義）
  - 業務規則的計算過程（中間步驟、條件判斷）
  - 計算結果的展示（原始值、調整後的值）
  - 狀態資訊（若規格有定義狀態轉換）

**範例說明（以電影院訂票系統為例）：**
- 若規格定義「票價計算規則」，前端要顯示：基本票價、折扣計算過程、最終票價
- 若規格定義「座位選擇規則」，前端要顯示：已選座位、座位狀態、選擇結果驗證
- 若規格定義「會員優惠規則」，前端要顯示：會員等級、適用優惠項目、折扣金額

### 6. 容器化與可驗收原則
- 所有應用必須透過 Docker 容器化
- 使用 Docker Compose 一鍵啟動所有服務（資料庫 + 應用）
- **AI 必須自行驗收**：部署完成後實際訪問網頁入口，確認應用可正常運行

---

## 執行步驟

### 階段 1：深度理解規格

#### 1.1 研讀資料模型
- 讀取 `spec/erm.dbml`
- 識別所有實體 (Table)、屬性 (Column)、關係 (Relationship)
- 記錄每個屬性的定義、資料型別、限制條件
- 記錄所有跨屬性不變條件

#### 1.2 研讀功能模型
- 讀取 `spec/features/` 下所有 `.feature` 檔案
- 識別每個 Feature 及其涵蓋的所有 Rule
- 研讀每個 Rule 的所有 Example（Given-When-Then）
- **特別注意**：
  - 前置條件（Pre-condition）：功能執行前的驗證規則
  - 後置條件（Post-condition）：功能執行後的系統狀態變更

#### 1.3 建立規格檢查清單
在開始開發前，建立內部檢查清單：
- [ ] 已識別所有實體與屬性
- [ ] 已識別所有實體關係
- [ ] 已識別所有功能與規則
- [ ] 已理解每個規則的所有 Example
- [ ] 已記錄所有約束條件
- [ ] 已確認無任何規格遺漏或歧義

---

### 階段 2：資料庫設計與實作

#### 2.1 產生資料庫 Schema
- 依據 `spec/erm.dbml` 產生 PostgreSQL Schema
- 每個 Table 對應一個資料庫表格
- 每個 Column 對應一個欄位，資料型別對應如下：
  - `int` → `INTEGER` 或 `SERIAL`
  - `long` → `BIGINT`
  - `float` → `NUMERIC` 或 `DECIMAL`
  - `bool` → `BOOLEAN`
  - `string` → `VARCHAR` 或 `TEXT`

#### 2.2 實作約束條件
對於 ERM 中每個屬性的 note 所描述的限制條件，使用 SQL Constraints 實作：
- 數值範圍限制 → `CHECK` constraint
- 唯一性限制 → `UNIQUE` constraint
- 非空限制 → `NOT NULL`
- 外鍵關聯 → `FOREIGN KEY`
- 跨屬性不變條件 → `CHECK` constraint（涉及多欄位）

#### 2.3 建立測試資料（Seed Data）【重要】
**必須建立豐富的測試資料，讓觀眾能立即操作驗證功能**

測試資料建立原則：
1. **識別核心實體**：根據 `spec/erm.dbml` 識別系統的核心實體
2. **建立基礎資料**：為每個核心實體建立至少 5-10 筆測試資料
3. **涵蓋測試場景**：測試資料要能觸發 Feature Files 中的各種 Rules

**範例說明（以電影院訂票系統為例）：**
- **影片資料**：至少 5 部電影（不同片長、分級、類型）
- **場次資料**：每部電影至少 3 個場次（不同時段、廳別）
- **座位資料**：每個廳至少 20 個座位（不同區域、不同票價）
- **會員資料**：至少 3 位測試會員（不同等級、不同積分）

測試資料設計要能觸發各種規則：
- 邊界條件（例如：最低/最高票價、滿座/空位）
- 業務規則（例如：會員折扣、早鳥優惠、團購優惠）
- 錯誤情境（例如：已售出座位、過期場次）

#### 2.4 建立初始化腳本
- 產生 `init.sql` 或 `schema.sql`
- **必須包含以下完整內容**：
  1. CREATE TABLE 語句（所有資料表）
  2. ALTER TABLE 語句（外鍵、約束）
  3. **INSERT 語句（所有核心實體的測試資料）**
- 腳本必須可重複執行（DROP IF EXISTS 或其他機制）

---

### 階段 3：後端開發

**重點：正確實作所有規則，使用指定的技術棧，架構採用最簡單可行的方式**

#### 3.1 實作策略
- 使用「技術棧配置」中指定的後端框架與工具
- 程式碼組織方式不拘，採用最簡單可行的方式
- **關鍵是：每條規則都要正確實作，邏輯清楚易讀**

#### 3.2 API Endpoints 設計

根據 `spec/features/` 中的 Feature Files，為每個主要操作建立對應的 API 端點。

**API 設計原則**：
1. 為每個 Feature 建立至少一個主要 API 端點
2. 查詢類操作使用 GET，變更類操作使用 POST/PUT/DELETE
3. 回傳適當的 HTTP 狀態碼與錯誤訊息
4. API 路徑命名清楚反映功能

#### 3.3 規則實作與註解（核心重點）
**必須將每條規則以註解形式逐條抄寫，並確保實作正確**

**註解格式要求**：
```
/**
 * Feature: [Feature 名稱]
 * Rule: [Rule 描述]
 * 對應規格：spec/features/[檔案名稱].feature
 */
```

**所有規則必須逐條實作**：
- 識別 `spec/features/` 中所有 `.feature` 檔案的 Rules
- 每條 Rule 都要有對應的註解與實作
- 特別注意複雜規則：
  - 多步驟計算邏輯
  - 條件判斷與分支處理
  - 多重規則疊加順序

#### 3.4 資料庫連線
- 使用「技術棧配置」中指定的資料庫 client/ORM
- 使用參數化查詢防止 SQL Injection
- 確保資料庫連線設定可透過環境變數配置

---

### 階段 4：前端開發【關鍵階段】

**核心目標：讓觀眾透過網頁操作，親眼驗證所有規則都被正確實作**

#### 4.1 實作策略
- 使用「技術棧配置」中指定的前端框架與工具
- 樣式設計不需精美，但資訊必須清楚易讀
- 重點是功能完整與規則展示清楚

#### 4.2 頁面規劃
根據 `spec/features/` 中的 Feature Files 規劃前端頁面結構。

**頁面規劃原則**：
1. 每個主要 Feature 至少有一個對應的操作介面
2. 頁面之間的導航流程符合使用者操作順序
3. 關鍵操作結果要有專門的展示頁面

#### 4.3 前端必須完整展示的資訊（非常重要）

**在結果展示頁面，必須清楚顯示：**

1. **主要資料明細**：根據規格顯示核心資料
   
2. **計算前的原始值**：明確標示計算前的基礎數值
   
3. **業務規則計算過程**（這是重點）：
   - 每一條被觸發的規則都要列出
   - 顯示規則的判斷條件與結果
   - 顯示規則對數值的影響
   - 多重規則疊加時，要顯示套用順序

4. **最終計算結果**：明確標示最終數值

5. **狀態資訊**（若規格有定義）：顯示當前狀態

**為什麼這很重要？**
觀眾要能透過前端畫面，直接對照 Feature File 中的 Examples，確認規則是否正確觸發、計算過程是否正確、最終結果是否符合預期。

#### 4.4 測試場景建議
前端應該讓觀眾能輕易重現 Feature Files 中的各種場景：
- 基本流程（無特殊規則觸發）
- 各種業務規則的觸發情境
- 多重規則疊加的情境
- 邊界條件測試（根據規格定義的邊界值）
- 錯誤情境（違反前置條件的操作）

---

### 階段 5：容器化與部署【關鍵階段】

#### 5.1 撰寫 Dockerfile
- 使用「技術棧配置」中指定的 base image
- 根據所選技術棧設計適當的多階段構建（若適用）
- 產生最佳化的生產版本
- 確保應用程式可在容器中正常運作

**重點**：不只是寫出 Dockerfile，要確保能成功 build

#### 5.2 撰寫 docker-compose.yml
- 定義所有必要的服務：
  - 資料庫服務（使用指定的資料庫類型與版本）
  - 應用程式服務（前後端）
- 設定網路連接
- 設定環境變數
- 設定資料持久化（Volume）
- 確保資料庫初始化腳本 (init.sql) 會被執行

**重點**：不只是寫出 docker-compose.yml，要確保能成功啟動所有服務

#### 5.3 建立環境變數檔案
- 建立 `.env.example` 提供環境變數範本
- 記錄所有必要的環境變數（資料庫連線、應用程式 port 等）

---

### 階段 6：自動化驗收【最關鍵階段】

#### 6.1 Docker 部署測試
**AI 必須實際執行以下步驟並確認結果：**

1. **Build Docker Images**
   - 執行：`docker-compose build`
   - 確認：Build 過程無錯誤，所有 images 成功建立

2. **啟動所有服務**
   - 執行：`docker-compose up -d`
   - 確認：所有容器成功啟動

3. **檢查容器狀態**
   - 執行：`docker-compose ps`
   - 確認：所有容器的 State 為 "Up"

4. **檢查資料庫初始化**
   - 查看資料庫容器日誌
   - 確認：init.sql 成功執行，測試資料已載入

5. **檢查應用程式日誌**
   - 查看應用程式容器日誌
   - 確認：應用程式成功啟動，無嚴重錯誤

6. **訪問應用程式**
   - 執行：`curl http://localhost:[PORT]` 或使用瀏覽器
   - 確認：應用程式可正常回應，首頁可載入

**重點**：不是寫完就算，必須實際 build、run、驗證

#### 6.2 功能驗收清單
**AI 必須透過實際操作（瀏覽器或 API 測試）驗證以下事項：**

**基本功能驗收：**
- [ ] 所有主要頁面可正常顯示
- [ ] 核心資料正確顯示（依 ERM 定義）
- [ ] 基本操作流程可正常執行

**規則驗收（核心重點）：**
必須至少測試以下場景，確認規則正確實作：

1. **基本操作規則**：
   - [ ] 正常情況下的操作成功
   - [ ] 違反前置條件時操作失敗，並顯示正確錯誤訊息
   - [ ] 邊界條件正確處理

2. **業務規則驗證**：
   - [ ] 每條業務規則都被正確觸發
   - [ ] 規則的計算邏輯正確
   - [ ] 規則的條件判斷正確

3. **複雜規則驗證**：
   - [ ] 多重規則疊加時，套用順序正確
   - [ ] 多重規則疊加時，計算結果正確
   - [ ] 特殊情境下的規則處理正確

4. **前端展示驗收**：
   - [ ] 結果展示頁面清楚顯示計算前的原始值
   - [ ] 結果展示頁面清楚顯示最終計算結果
   - [ ] 有套用規則時，清楚列出每一條規則的計算過程
   - [ ] 計算過程與結果都正確

#### 6.3 驗收報告
產出驗收報告，包含：
- Docker build 與 run 的執行結果
- 容器狀態確認
- 應用程式訪問測試結果
- 功能驗收清單完成狀態
- 測試的具體場景與結果
- 發現的問題或限制（如有）

**驗收標準**：
- Docker Compose 可一鍵啟動所有服務
- 應用程式可正常訪問
- 至少測試 3 個關鍵業務規則，確認計算正確
- 前端正確展示規則計算過程

---

## 行為規則

### 開發階段規則
1. **功能正確性第一**：功能對比架構美重要 100 倍，用最簡單的方式正確實作所有規則
2. **嚴格遵守規格**：任何實作都必須有明確的規格依據，禁止腦補
3. **規則可追溯**：每個規則實作都要加註解，能追溯到具體的規格條目
4. **前端展示完整**：觀眾要能透過前端畫面驗證所有規則，業務規則計算過程必須清楚展示
5. **測試資料豐富**：Seed data 要包含足夠的測試資料，讓觀眾能輕易測試各種場景
6. **約束強制**：資料約束優先在資料庫層面實作

### 驗收階段規則
1. **實際執行**：不能只產出程式碼就結束，必須實際部署測試
2. **親自驗證**：必須透過網頁操作確認功能可用，測試關鍵場景
3. **規則驗證**：特別驗證複雜規則（多步驟計算、多重規則疊加等）
4. **問題修正**：發現問題必須立即修正，直到驗收通過
5. **不能假設**：不能假設「應該可以」，必須實際確認「真的可以」

### 溝通規則
1. **階段性報告**：每完成一個階段都要報告進度
2. **問題回報**：發現規格歧義或遺漏時立即回報
3. **不自行決定**：遇到規格未涵蓋的情況，詢問使用者而非自行決定

### 禁止事項
1. 不要花時間設計複雜的架構（Repository Pattern、DDD 等非必要）
2. 不要實作規格中沒有提到的功能
3. 不要添加「可能需要」的欄位或功能
4. 不要只顯示最終結果而不顯示業務規則計算過程
5. 不要在驗收時只測試「能不能跑」，要測試「規則對不對」

---

## 輸出產物

### 1. 原始碼
- 使用指定技術棧的完整專案程式碼
- 包含前端、後端、資料庫連線
- 依賴管理檔案（package.json / requirements.txt / pom.xml 等）包含所有必要依賴

### 2. 資料庫腳本
- `init.sql`：資料庫初始化腳本
- **必須包含**：
  - 所有 CREATE TABLE、Constraints、索引
  - 所有核心實體的測試資料 INSERT 語句
  - 測試資料要能涵蓋各種測試場景

### 3. 容器化檔案【必要】
- `Dockerfile`：應用程式容器化定義
- `docker-compose.yml`：多容器編排配置
- `.env.example`：環境變數範本

### 4. 文件
- `README.md`：專案說明、技術棧、啟動指令
- 簡要說明專案結構

### 5. 驗收報告【必要】
- Docker build 與 run 執行結果
- 容器狀態確認
- 應用程式訪問測試結果
- 功能驗收清單
- 已知問題或限制（如有）

---

## 完成標準

任務完成必須滿足以下所有條件：

**規格理解：**
- [ ] 已完整讀取並理解 `spec/erm.dbml` 與所有 `spec/features/*.feature`
- [ ] 已識別所有需要實作的規則（統計 Feature Files 中的所有 Rules）

**資料庫實作：**
- [ ] 資料庫 Schema 完整對應 ERM，所有約束都已實作
- [ ] `init.sql` 包含所有核心實體的測試資料
- [ ] 測試資料設計能觸發 Feature Files 中的各種測試場景

**後端實作：**
- [ ] 所有規則都已在程式碼中以註解形式抄寫
- [ ] 所有規則都已正確實作（特別是多步驟計算、多重規則疊加）
- [ ] API Endpoints 完整（涵蓋所有 Feature 的操作）

**前端實作（關鍵）：**
- [ ] 前端介面能夠模擬所有 Feature 的操作流程
- [ ] 結果展示頁面清楚顯示計算前的原始值
- [ ] 結果展示頁面清楚顯示最終計算結果
- [ ] 結果展示頁面清楚列出所有業務規則的計算過程
- [ ] 觀眾能透過前端畫面驗證 Feature File 中的 Examples

**容器化與部署：**
- [ ] Dockerfile 與 docker-compose.yml 已完成
- [ ] AI 已實際執行 `docker-compose build` 並確認 build 成功
- [ ] AI 已實際執行 `docker-compose up` 並確認所有容器成功啟動
- [ ] AI 已檢查容器狀態，確認所有服務正常運行
- [ ] AI 已透過網頁或 API 實際訪問應用並確認可正常運作

**功能驗收（最關鍵）：**
- [ ] 已測試所有 Feature 的基本操作流程
- [ ] 已測試所有業務規則的觸發條件與計算邏輯
- [ ] 已測試邊界條件
- [ ] 已測試多重規則疊加的情境
- [ ] 前端正確顯示所有業務規則的計算過程
- [ ] 驗收報告已產出，所有驗收項目都已通過

**品質標準：**
- [ ] 所有程式碼基於規格實作，無任何腦補或假設內容
- [ ] 沒有實作規格外的功能

---

## 與其他 Prompt 的關係

- **前置階段**：`discovery.md`、`clarify-and-translation.md`、`formulation.md` 已產出完整規格
- **本階段角色**：自動化開發階段，將完整規格轉換為可運行的應用程式
- **後續階段**：無（本階段為最終實作階段）

---

## 注意事項

### 最重要的三件事
1. **功能必須正確**：每條規則都要 100% 正確實作，尤其是複雜的業務邏輯
2. **前端必須展示計算過程**：觀眾要能看到業務規則如何運作，不是只有最終結果
3. **測試資料必須充足**：涵蓋各種測試場景所需的資料

### 開發注意事項
1. **架構不重要**：用最簡單的方式實作，不要花時間在 Clean Architecture 上
2. **絕對不要腦補**：規格沒有提到的欄位、功能或規則，就不要實作
3. **只實作規格定義的功能**：沒有在 Feature Files 中出現的功能，不要實作
4. **遇到歧義立即停止**：發現規格有歧義或遺漏時，回報使用者而非自行決定

### 驗收注意事項
1. **驗收是必要步驟**：不能只寫完程式碼就結束，必須實際部署並測試
2. **Docker 必須能 build 與 run**：不是寫完 Dockerfile 就好，要實際執行並確認成功
3. **要測試規則正確性**：不是測試「能不能跑」，而是測試「算對沒有」
4. **重點測試複雜規則**：多步驟計算、條件分支、多重規則疊加
5. **資料約束很重要**：資料庫層面的約束是防止錯誤資料的第一道防線

### 成功的標準
- 觀眾能透過網頁操作，重現 Feature File 中的任一 Example
- 前端清楚顯示每一條業務規則的計算過程
- 所有邊界條件都正確處理
- 多重規則疊加計算完全正確
